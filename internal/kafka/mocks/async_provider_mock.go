// Code generated by http://github.com/gojuno/minimock (v3.4.1). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/IBM/sarama.AsyncProducer -o async_provider_mock.go -n AsyncProducerMock -p mocks

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	mm_sarama "github.com/IBM/sarama"
	"github.com/gojuno/minimock/v3"
)

// AsyncProducerMock implements mm_sarama.AsyncProducer
type AsyncProducerMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAbortTxn          func() (err error)
	funcAbortTxnOrigin    string
	inspectFuncAbortTxn   func()
	afterAbortTxnCounter  uint64
	beforeAbortTxnCounter uint64
	AbortTxnMock          mAsyncProducerMockAbortTxn

	funcAddMessageToTxn          func(msg *mm_sarama.ConsumerMessage, groupId string, metadata *string) (err error)
	funcAddMessageToTxnOrigin    string
	inspectFuncAddMessageToTxn   func(msg *mm_sarama.ConsumerMessage, groupId string, metadata *string)
	afterAddMessageToTxnCounter  uint64
	beforeAddMessageToTxnCounter uint64
	AddMessageToTxnMock          mAsyncProducerMockAddMessageToTxn

	funcAddOffsetsToTxn          func(offsets map[string][]*mm_sarama.PartitionOffsetMetadata, groupId string) (err error)
	funcAddOffsetsToTxnOrigin    string
	inspectFuncAddOffsetsToTxn   func(offsets map[string][]*mm_sarama.PartitionOffsetMetadata, groupId string)
	afterAddOffsetsToTxnCounter  uint64
	beforeAddOffsetsToTxnCounter uint64
	AddOffsetsToTxnMock          mAsyncProducerMockAddOffsetsToTxn

	funcAsyncClose          func()
	funcAsyncCloseOrigin    string
	inspectFuncAsyncClose   func()
	afterAsyncCloseCounter  uint64
	beforeAsyncCloseCounter uint64
	AsyncCloseMock          mAsyncProducerMockAsyncClose

	funcBeginTxn          func() (err error)
	funcBeginTxnOrigin    string
	inspectFuncBeginTxn   func()
	afterBeginTxnCounter  uint64
	beforeBeginTxnCounter uint64
	BeginTxnMock          mAsyncProducerMockBeginTxn

	funcClose          func() (err error)
	funcCloseOrigin    string
	inspectFuncClose   func()
	afterCloseCounter  uint64
	beforeCloseCounter uint64
	CloseMock          mAsyncProducerMockClose

	funcCommitTxn          func() (err error)
	funcCommitTxnOrigin    string
	inspectFuncCommitTxn   func()
	afterCommitTxnCounter  uint64
	beforeCommitTxnCounter uint64
	CommitTxnMock          mAsyncProducerMockCommitTxn

	funcErrors          func() (ch1 <-chan *mm_sarama.ProducerError)
	funcErrorsOrigin    string
	inspectFuncErrors   func()
	afterErrorsCounter  uint64
	beforeErrorsCounter uint64
	ErrorsMock          mAsyncProducerMockErrors

	funcInput          func() (ch1 chan<- *mm_sarama.ProducerMessage)
	funcInputOrigin    string
	inspectFuncInput   func()
	afterInputCounter  uint64
	beforeInputCounter uint64
	InputMock          mAsyncProducerMockInput

	funcIsTransactional          func() (b1 bool)
	funcIsTransactionalOrigin    string
	inspectFuncIsTransactional   func()
	afterIsTransactionalCounter  uint64
	beforeIsTransactionalCounter uint64
	IsTransactionalMock          mAsyncProducerMockIsTransactional

	funcSuccesses          func() (ch1 <-chan *mm_sarama.ProducerMessage)
	funcSuccessesOrigin    string
	inspectFuncSuccesses   func()
	afterSuccessesCounter  uint64
	beforeSuccessesCounter uint64
	SuccessesMock          mAsyncProducerMockSuccesses

	funcTxnStatus          func() (p1 mm_sarama.ProducerTxnStatusFlag)
	funcTxnStatusOrigin    string
	inspectFuncTxnStatus   func()
	afterTxnStatusCounter  uint64
	beforeTxnStatusCounter uint64
	TxnStatusMock          mAsyncProducerMockTxnStatus
}

// NewAsyncProducerMock returns a mock for mm_sarama.AsyncProducer
func NewAsyncProducerMock(t minimock.Tester) *AsyncProducerMock {
	m := &AsyncProducerMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AbortTxnMock = mAsyncProducerMockAbortTxn{mock: m}

	m.AddMessageToTxnMock = mAsyncProducerMockAddMessageToTxn{mock: m}
	m.AddMessageToTxnMock.callArgs = []*AsyncProducerMockAddMessageToTxnParams{}

	m.AddOffsetsToTxnMock = mAsyncProducerMockAddOffsetsToTxn{mock: m}
	m.AddOffsetsToTxnMock.callArgs = []*AsyncProducerMockAddOffsetsToTxnParams{}

	m.AsyncCloseMock = mAsyncProducerMockAsyncClose{mock: m}

	m.BeginTxnMock = mAsyncProducerMockBeginTxn{mock: m}

	m.CloseMock = mAsyncProducerMockClose{mock: m}

	m.CommitTxnMock = mAsyncProducerMockCommitTxn{mock: m}

	m.ErrorsMock = mAsyncProducerMockErrors{mock: m}

	m.InputMock = mAsyncProducerMockInput{mock: m}

	m.IsTransactionalMock = mAsyncProducerMockIsTransactional{mock: m}

	m.SuccessesMock = mAsyncProducerMockSuccesses{mock: m}

	m.TxnStatusMock = mAsyncProducerMockTxnStatus{mock: m}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mAsyncProducerMockAbortTxn struct {
	optional           bool
	mock               *AsyncProducerMock
	defaultExpectation *AsyncProducerMockAbortTxnExpectation
	expectations       []*AsyncProducerMockAbortTxnExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AsyncProducerMockAbortTxnExpectation specifies expectation struct of the AsyncProducer.AbortTxn
type AsyncProducerMockAbortTxnExpectation struct {
	mock *AsyncProducerMock

	results      *AsyncProducerMockAbortTxnResults
	returnOrigin string
	Counter      uint64
}

// AsyncProducerMockAbortTxnResults contains results of the AsyncProducer.AbortTxn
type AsyncProducerMockAbortTxnResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAbortTxn *mAsyncProducerMockAbortTxn) Optional() *mAsyncProducerMockAbortTxn {
	mmAbortTxn.optional = true
	return mmAbortTxn
}

// Expect sets up expected params for AsyncProducer.AbortTxn
func (mmAbortTxn *mAsyncProducerMockAbortTxn) Expect() *mAsyncProducerMockAbortTxn {
	if mmAbortTxn.mock.funcAbortTxn != nil {
		mmAbortTxn.mock.t.Fatalf("AsyncProducerMock.AbortTxn mock is already set by Set")
	}

	if mmAbortTxn.defaultExpectation == nil {
		mmAbortTxn.defaultExpectation = &AsyncProducerMockAbortTxnExpectation{}
	}

	return mmAbortTxn
}

// Inspect accepts an inspector function that has same arguments as the AsyncProducer.AbortTxn
func (mmAbortTxn *mAsyncProducerMockAbortTxn) Inspect(f func()) *mAsyncProducerMockAbortTxn {
	if mmAbortTxn.mock.inspectFuncAbortTxn != nil {
		mmAbortTxn.mock.t.Fatalf("Inspect function is already set for AsyncProducerMock.AbortTxn")
	}

	mmAbortTxn.mock.inspectFuncAbortTxn = f

	return mmAbortTxn
}

// Return sets up results that will be returned by AsyncProducer.AbortTxn
func (mmAbortTxn *mAsyncProducerMockAbortTxn) Return(err error) *AsyncProducerMock {
	if mmAbortTxn.mock.funcAbortTxn != nil {
		mmAbortTxn.mock.t.Fatalf("AsyncProducerMock.AbortTxn mock is already set by Set")
	}

	if mmAbortTxn.defaultExpectation == nil {
		mmAbortTxn.defaultExpectation = &AsyncProducerMockAbortTxnExpectation{mock: mmAbortTxn.mock}
	}
	mmAbortTxn.defaultExpectation.results = &AsyncProducerMockAbortTxnResults{err}
	mmAbortTxn.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAbortTxn.mock
}

// Set uses given function f to mock the AsyncProducer.AbortTxn method
func (mmAbortTxn *mAsyncProducerMockAbortTxn) Set(f func() (err error)) *AsyncProducerMock {
	if mmAbortTxn.defaultExpectation != nil {
		mmAbortTxn.mock.t.Fatalf("Default expectation is already set for the AsyncProducer.AbortTxn method")
	}

	if len(mmAbortTxn.expectations) > 0 {
		mmAbortTxn.mock.t.Fatalf("Some expectations are already set for the AsyncProducer.AbortTxn method")
	}

	mmAbortTxn.mock.funcAbortTxn = f
	mmAbortTxn.mock.funcAbortTxnOrigin = minimock.CallerInfo(1)
	return mmAbortTxn.mock
}

// Times sets number of times AsyncProducer.AbortTxn should be invoked
func (mmAbortTxn *mAsyncProducerMockAbortTxn) Times(n uint64) *mAsyncProducerMockAbortTxn {
	if n == 0 {
		mmAbortTxn.mock.t.Fatalf("Times of AsyncProducerMock.AbortTxn mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAbortTxn.expectedInvocations, n)
	mmAbortTxn.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAbortTxn
}

func (mmAbortTxn *mAsyncProducerMockAbortTxn) invocationsDone() bool {
	if len(mmAbortTxn.expectations) == 0 && mmAbortTxn.defaultExpectation == nil && mmAbortTxn.mock.funcAbortTxn == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAbortTxn.mock.afterAbortTxnCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAbortTxn.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AbortTxn implements mm_sarama.AsyncProducer
func (mmAbortTxn *AsyncProducerMock) AbortTxn() (err error) {
	mm_atomic.AddUint64(&mmAbortTxn.beforeAbortTxnCounter, 1)
	defer mm_atomic.AddUint64(&mmAbortTxn.afterAbortTxnCounter, 1)

	mmAbortTxn.t.Helper()

	if mmAbortTxn.inspectFuncAbortTxn != nil {
		mmAbortTxn.inspectFuncAbortTxn()
	}

	if mmAbortTxn.AbortTxnMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAbortTxn.AbortTxnMock.defaultExpectation.Counter, 1)

		mm_results := mmAbortTxn.AbortTxnMock.defaultExpectation.results
		if mm_results == nil {
			mmAbortTxn.t.Fatal("No results are set for the AsyncProducerMock.AbortTxn")
		}
		return (*mm_results).err
	}
	if mmAbortTxn.funcAbortTxn != nil {
		return mmAbortTxn.funcAbortTxn()
	}
	mmAbortTxn.t.Fatalf("Unexpected call to AsyncProducerMock.AbortTxn.")
	return
}

// AbortTxnAfterCounter returns a count of finished AsyncProducerMock.AbortTxn invocations
func (mmAbortTxn *AsyncProducerMock) AbortTxnAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAbortTxn.afterAbortTxnCounter)
}

// AbortTxnBeforeCounter returns a count of AsyncProducerMock.AbortTxn invocations
func (mmAbortTxn *AsyncProducerMock) AbortTxnBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAbortTxn.beforeAbortTxnCounter)
}

// MinimockAbortTxnDone returns true if the count of the AbortTxn invocations corresponds
// the number of defined expectations
func (m *AsyncProducerMock) MinimockAbortTxnDone() bool {
	if m.AbortTxnMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AbortTxnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AbortTxnMock.invocationsDone()
}

// MinimockAbortTxnInspect logs each unmet expectation
func (m *AsyncProducerMock) MinimockAbortTxnInspect() {
	for _, e := range m.AbortTxnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to AsyncProducerMock.AbortTxn")
		}
	}

	afterAbortTxnCounter := mm_atomic.LoadUint64(&m.afterAbortTxnCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AbortTxnMock.defaultExpectation != nil && afterAbortTxnCounter < 1 {
		m.t.Errorf("Expected call to AsyncProducerMock.AbortTxn at\n%s", m.AbortTxnMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAbortTxn != nil && afterAbortTxnCounter < 1 {
		m.t.Errorf("Expected call to AsyncProducerMock.AbortTxn at\n%s", m.funcAbortTxnOrigin)
	}

	if !m.AbortTxnMock.invocationsDone() && afterAbortTxnCounter > 0 {
		m.t.Errorf("Expected %d calls to AsyncProducerMock.AbortTxn at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AbortTxnMock.expectedInvocations), m.AbortTxnMock.expectedInvocationsOrigin, afterAbortTxnCounter)
	}
}

type mAsyncProducerMockAddMessageToTxn struct {
	optional           bool
	mock               *AsyncProducerMock
	defaultExpectation *AsyncProducerMockAddMessageToTxnExpectation
	expectations       []*AsyncProducerMockAddMessageToTxnExpectation

	callArgs []*AsyncProducerMockAddMessageToTxnParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AsyncProducerMockAddMessageToTxnExpectation specifies expectation struct of the AsyncProducer.AddMessageToTxn
type AsyncProducerMockAddMessageToTxnExpectation struct {
	mock               *AsyncProducerMock
	params             *AsyncProducerMockAddMessageToTxnParams
	paramPtrs          *AsyncProducerMockAddMessageToTxnParamPtrs
	expectationOrigins AsyncProducerMockAddMessageToTxnExpectationOrigins
	results            *AsyncProducerMockAddMessageToTxnResults
	returnOrigin       string
	Counter            uint64
}

// AsyncProducerMockAddMessageToTxnParams contains parameters of the AsyncProducer.AddMessageToTxn
type AsyncProducerMockAddMessageToTxnParams struct {
	msg      *mm_sarama.ConsumerMessage
	groupId  string
	metadata *string
}

// AsyncProducerMockAddMessageToTxnParamPtrs contains pointers to parameters of the AsyncProducer.AddMessageToTxn
type AsyncProducerMockAddMessageToTxnParamPtrs struct {
	msg      **mm_sarama.ConsumerMessage
	groupId  *string
	metadata **string
}

// AsyncProducerMockAddMessageToTxnResults contains results of the AsyncProducer.AddMessageToTxn
type AsyncProducerMockAddMessageToTxnResults struct {
	err error
}

// AsyncProducerMockAddMessageToTxnOrigins contains origins of expectations of the AsyncProducer.AddMessageToTxn
type AsyncProducerMockAddMessageToTxnExpectationOrigins struct {
	origin         string
	originMsg      string
	originGroupId  string
	originMetadata string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddMessageToTxn *mAsyncProducerMockAddMessageToTxn) Optional() *mAsyncProducerMockAddMessageToTxn {
	mmAddMessageToTxn.optional = true
	return mmAddMessageToTxn
}

// Expect sets up expected params for AsyncProducer.AddMessageToTxn
func (mmAddMessageToTxn *mAsyncProducerMockAddMessageToTxn) Expect(msg *mm_sarama.ConsumerMessage, groupId string, metadata *string) *mAsyncProducerMockAddMessageToTxn {
	if mmAddMessageToTxn.mock.funcAddMessageToTxn != nil {
		mmAddMessageToTxn.mock.t.Fatalf("AsyncProducerMock.AddMessageToTxn mock is already set by Set")
	}

	if mmAddMessageToTxn.defaultExpectation == nil {
		mmAddMessageToTxn.defaultExpectation = &AsyncProducerMockAddMessageToTxnExpectation{}
	}

	if mmAddMessageToTxn.defaultExpectation.paramPtrs != nil {
		mmAddMessageToTxn.mock.t.Fatalf("AsyncProducerMock.AddMessageToTxn mock is already set by ExpectParams functions")
	}

	mmAddMessageToTxn.defaultExpectation.params = &AsyncProducerMockAddMessageToTxnParams{msg, groupId, metadata}
	mmAddMessageToTxn.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddMessageToTxn.expectations {
		if minimock.Equal(e.params, mmAddMessageToTxn.defaultExpectation.params) {
			mmAddMessageToTxn.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddMessageToTxn.defaultExpectation.params)
		}
	}

	return mmAddMessageToTxn
}

// ExpectMsgParam1 sets up expected param msg for AsyncProducer.AddMessageToTxn
func (mmAddMessageToTxn *mAsyncProducerMockAddMessageToTxn) ExpectMsgParam1(msg *mm_sarama.ConsumerMessage) *mAsyncProducerMockAddMessageToTxn {
	if mmAddMessageToTxn.mock.funcAddMessageToTxn != nil {
		mmAddMessageToTxn.mock.t.Fatalf("AsyncProducerMock.AddMessageToTxn mock is already set by Set")
	}

	if mmAddMessageToTxn.defaultExpectation == nil {
		mmAddMessageToTxn.defaultExpectation = &AsyncProducerMockAddMessageToTxnExpectation{}
	}

	if mmAddMessageToTxn.defaultExpectation.params != nil {
		mmAddMessageToTxn.mock.t.Fatalf("AsyncProducerMock.AddMessageToTxn mock is already set by Expect")
	}

	if mmAddMessageToTxn.defaultExpectation.paramPtrs == nil {
		mmAddMessageToTxn.defaultExpectation.paramPtrs = &AsyncProducerMockAddMessageToTxnParamPtrs{}
	}
	mmAddMessageToTxn.defaultExpectation.paramPtrs.msg = &msg
	mmAddMessageToTxn.defaultExpectation.expectationOrigins.originMsg = minimock.CallerInfo(1)

	return mmAddMessageToTxn
}

// ExpectGroupIdParam2 sets up expected param groupId for AsyncProducer.AddMessageToTxn
func (mmAddMessageToTxn *mAsyncProducerMockAddMessageToTxn) ExpectGroupIdParam2(groupId string) *mAsyncProducerMockAddMessageToTxn {
	if mmAddMessageToTxn.mock.funcAddMessageToTxn != nil {
		mmAddMessageToTxn.mock.t.Fatalf("AsyncProducerMock.AddMessageToTxn mock is already set by Set")
	}

	if mmAddMessageToTxn.defaultExpectation == nil {
		mmAddMessageToTxn.defaultExpectation = &AsyncProducerMockAddMessageToTxnExpectation{}
	}

	if mmAddMessageToTxn.defaultExpectation.params != nil {
		mmAddMessageToTxn.mock.t.Fatalf("AsyncProducerMock.AddMessageToTxn mock is already set by Expect")
	}

	if mmAddMessageToTxn.defaultExpectation.paramPtrs == nil {
		mmAddMessageToTxn.defaultExpectation.paramPtrs = &AsyncProducerMockAddMessageToTxnParamPtrs{}
	}
	mmAddMessageToTxn.defaultExpectation.paramPtrs.groupId = &groupId
	mmAddMessageToTxn.defaultExpectation.expectationOrigins.originGroupId = minimock.CallerInfo(1)

	return mmAddMessageToTxn
}

// ExpectMetadataParam3 sets up expected param metadata for AsyncProducer.AddMessageToTxn
func (mmAddMessageToTxn *mAsyncProducerMockAddMessageToTxn) ExpectMetadataParam3(metadata *string) *mAsyncProducerMockAddMessageToTxn {
	if mmAddMessageToTxn.mock.funcAddMessageToTxn != nil {
		mmAddMessageToTxn.mock.t.Fatalf("AsyncProducerMock.AddMessageToTxn mock is already set by Set")
	}

	if mmAddMessageToTxn.defaultExpectation == nil {
		mmAddMessageToTxn.defaultExpectation = &AsyncProducerMockAddMessageToTxnExpectation{}
	}

	if mmAddMessageToTxn.defaultExpectation.params != nil {
		mmAddMessageToTxn.mock.t.Fatalf("AsyncProducerMock.AddMessageToTxn mock is already set by Expect")
	}

	if mmAddMessageToTxn.defaultExpectation.paramPtrs == nil {
		mmAddMessageToTxn.defaultExpectation.paramPtrs = &AsyncProducerMockAddMessageToTxnParamPtrs{}
	}
	mmAddMessageToTxn.defaultExpectation.paramPtrs.metadata = &metadata
	mmAddMessageToTxn.defaultExpectation.expectationOrigins.originMetadata = minimock.CallerInfo(1)

	return mmAddMessageToTxn
}

// Inspect accepts an inspector function that has same arguments as the AsyncProducer.AddMessageToTxn
func (mmAddMessageToTxn *mAsyncProducerMockAddMessageToTxn) Inspect(f func(msg *mm_sarama.ConsumerMessage, groupId string, metadata *string)) *mAsyncProducerMockAddMessageToTxn {
	if mmAddMessageToTxn.mock.inspectFuncAddMessageToTxn != nil {
		mmAddMessageToTxn.mock.t.Fatalf("Inspect function is already set for AsyncProducerMock.AddMessageToTxn")
	}

	mmAddMessageToTxn.mock.inspectFuncAddMessageToTxn = f

	return mmAddMessageToTxn
}

// Return sets up results that will be returned by AsyncProducer.AddMessageToTxn
func (mmAddMessageToTxn *mAsyncProducerMockAddMessageToTxn) Return(err error) *AsyncProducerMock {
	if mmAddMessageToTxn.mock.funcAddMessageToTxn != nil {
		mmAddMessageToTxn.mock.t.Fatalf("AsyncProducerMock.AddMessageToTxn mock is already set by Set")
	}

	if mmAddMessageToTxn.defaultExpectation == nil {
		mmAddMessageToTxn.defaultExpectation = &AsyncProducerMockAddMessageToTxnExpectation{mock: mmAddMessageToTxn.mock}
	}
	mmAddMessageToTxn.defaultExpectation.results = &AsyncProducerMockAddMessageToTxnResults{err}
	mmAddMessageToTxn.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddMessageToTxn.mock
}

// Set uses given function f to mock the AsyncProducer.AddMessageToTxn method
func (mmAddMessageToTxn *mAsyncProducerMockAddMessageToTxn) Set(f func(msg *mm_sarama.ConsumerMessage, groupId string, metadata *string) (err error)) *AsyncProducerMock {
	if mmAddMessageToTxn.defaultExpectation != nil {
		mmAddMessageToTxn.mock.t.Fatalf("Default expectation is already set for the AsyncProducer.AddMessageToTxn method")
	}

	if len(mmAddMessageToTxn.expectations) > 0 {
		mmAddMessageToTxn.mock.t.Fatalf("Some expectations are already set for the AsyncProducer.AddMessageToTxn method")
	}

	mmAddMessageToTxn.mock.funcAddMessageToTxn = f
	mmAddMessageToTxn.mock.funcAddMessageToTxnOrigin = minimock.CallerInfo(1)
	return mmAddMessageToTxn.mock
}

// When sets expectation for the AsyncProducer.AddMessageToTxn which will trigger the result defined by the following
// Then helper
func (mmAddMessageToTxn *mAsyncProducerMockAddMessageToTxn) When(msg *mm_sarama.ConsumerMessage, groupId string, metadata *string) *AsyncProducerMockAddMessageToTxnExpectation {
	if mmAddMessageToTxn.mock.funcAddMessageToTxn != nil {
		mmAddMessageToTxn.mock.t.Fatalf("AsyncProducerMock.AddMessageToTxn mock is already set by Set")
	}

	expectation := &AsyncProducerMockAddMessageToTxnExpectation{
		mock:               mmAddMessageToTxn.mock,
		params:             &AsyncProducerMockAddMessageToTxnParams{msg, groupId, metadata},
		expectationOrigins: AsyncProducerMockAddMessageToTxnExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddMessageToTxn.expectations = append(mmAddMessageToTxn.expectations, expectation)
	return expectation
}

// Then sets up AsyncProducer.AddMessageToTxn return parameters for the expectation previously defined by the When method
func (e *AsyncProducerMockAddMessageToTxnExpectation) Then(err error) *AsyncProducerMock {
	e.results = &AsyncProducerMockAddMessageToTxnResults{err}
	return e.mock
}

// Times sets number of times AsyncProducer.AddMessageToTxn should be invoked
func (mmAddMessageToTxn *mAsyncProducerMockAddMessageToTxn) Times(n uint64) *mAsyncProducerMockAddMessageToTxn {
	if n == 0 {
		mmAddMessageToTxn.mock.t.Fatalf("Times of AsyncProducerMock.AddMessageToTxn mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddMessageToTxn.expectedInvocations, n)
	mmAddMessageToTxn.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddMessageToTxn
}

func (mmAddMessageToTxn *mAsyncProducerMockAddMessageToTxn) invocationsDone() bool {
	if len(mmAddMessageToTxn.expectations) == 0 && mmAddMessageToTxn.defaultExpectation == nil && mmAddMessageToTxn.mock.funcAddMessageToTxn == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddMessageToTxn.mock.afterAddMessageToTxnCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddMessageToTxn.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddMessageToTxn implements mm_sarama.AsyncProducer
func (mmAddMessageToTxn *AsyncProducerMock) AddMessageToTxn(msg *mm_sarama.ConsumerMessage, groupId string, metadata *string) (err error) {
	mm_atomic.AddUint64(&mmAddMessageToTxn.beforeAddMessageToTxnCounter, 1)
	defer mm_atomic.AddUint64(&mmAddMessageToTxn.afterAddMessageToTxnCounter, 1)

	mmAddMessageToTxn.t.Helper()

	if mmAddMessageToTxn.inspectFuncAddMessageToTxn != nil {
		mmAddMessageToTxn.inspectFuncAddMessageToTxn(msg, groupId, metadata)
	}

	mm_params := AsyncProducerMockAddMessageToTxnParams{msg, groupId, metadata}

	// Record call args
	mmAddMessageToTxn.AddMessageToTxnMock.mutex.Lock()
	mmAddMessageToTxn.AddMessageToTxnMock.callArgs = append(mmAddMessageToTxn.AddMessageToTxnMock.callArgs, &mm_params)
	mmAddMessageToTxn.AddMessageToTxnMock.mutex.Unlock()

	for _, e := range mmAddMessageToTxn.AddMessageToTxnMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddMessageToTxn.AddMessageToTxnMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddMessageToTxn.AddMessageToTxnMock.defaultExpectation.Counter, 1)
		mm_want := mmAddMessageToTxn.AddMessageToTxnMock.defaultExpectation.params
		mm_want_ptrs := mmAddMessageToTxn.AddMessageToTxnMock.defaultExpectation.paramPtrs

		mm_got := AsyncProducerMockAddMessageToTxnParams{msg, groupId, metadata}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.msg != nil && !minimock.Equal(*mm_want_ptrs.msg, mm_got.msg) {
				mmAddMessageToTxn.t.Errorf("AsyncProducerMock.AddMessageToTxn got unexpected parameter msg, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddMessageToTxn.AddMessageToTxnMock.defaultExpectation.expectationOrigins.originMsg, *mm_want_ptrs.msg, mm_got.msg, minimock.Diff(*mm_want_ptrs.msg, mm_got.msg))
			}

			if mm_want_ptrs.groupId != nil && !minimock.Equal(*mm_want_ptrs.groupId, mm_got.groupId) {
				mmAddMessageToTxn.t.Errorf("AsyncProducerMock.AddMessageToTxn got unexpected parameter groupId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddMessageToTxn.AddMessageToTxnMock.defaultExpectation.expectationOrigins.originGroupId, *mm_want_ptrs.groupId, mm_got.groupId, minimock.Diff(*mm_want_ptrs.groupId, mm_got.groupId))
			}

			if mm_want_ptrs.metadata != nil && !minimock.Equal(*mm_want_ptrs.metadata, mm_got.metadata) {
				mmAddMessageToTxn.t.Errorf("AsyncProducerMock.AddMessageToTxn got unexpected parameter metadata, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddMessageToTxn.AddMessageToTxnMock.defaultExpectation.expectationOrigins.originMetadata, *mm_want_ptrs.metadata, mm_got.metadata, minimock.Diff(*mm_want_ptrs.metadata, mm_got.metadata))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddMessageToTxn.t.Errorf("AsyncProducerMock.AddMessageToTxn got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddMessageToTxn.AddMessageToTxnMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddMessageToTxn.AddMessageToTxnMock.defaultExpectation.results
		if mm_results == nil {
			mmAddMessageToTxn.t.Fatal("No results are set for the AsyncProducerMock.AddMessageToTxn")
		}
		return (*mm_results).err
	}
	if mmAddMessageToTxn.funcAddMessageToTxn != nil {
		return mmAddMessageToTxn.funcAddMessageToTxn(msg, groupId, metadata)
	}
	mmAddMessageToTxn.t.Fatalf("Unexpected call to AsyncProducerMock.AddMessageToTxn. %v %v %v", msg, groupId, metadata)
	return
}

// AddMessageToTxnAfterCounter returns a count of finished AsyncProducerMock.AddMessageToTxn invocations
func (mmAddMessageToTxn *AsyncProducerMock) AddMessageToTxnAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddMessageToTxn.afterAddMessageToTxnCounter)
}

// AddMessageToTxnBeforeCounter returns a count of AsyncProducerMock.AddMessageToTxn invocations
func (mmAddMessageToTxn *AsyncProducerMock) AddMessageToTxnBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddMessageToTxn.beforeAddMessageToTxnCounter)
}

// Calls returns a list of arguments used in each call to AsyncProducerMock.AddMessageToTxn.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddMessageToTxn *mAsyncProducerMockAddMessageToTxn) Calls() []*AsyncProducerMockAddMessageToTxnParams {
	mmAddMessageToTxn.mutex.RLock()

	argCopy := make([]*AsyncProducerMockAddMessageToTxnParams, len(mmAddMessageToTxn.callArgs))
	copy(argCopy, mmAddMessageToTxn.callArgs)

	mmAddMessageToTxn.mutex.RUnlock()

	return argCopy
}

// MinimockAddMessageToTxnDone returns true if the count of the AddMessageToTxn invocations corresponds
// the number of defined expectations
func (m *AsyncProducerMock) MinimockAddMessageToTxnDone() bool {
	if m.AddMessageToTxnMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddMessageToTxnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddMessageToTxnMock.invocationsDone()
}

// MinimockAddMessageToTxnInspect logs each unmet expectation
func (m *AsyncProducerMock) MinimockAddMessageToTxnInspect() {
	for _, e := range m.AddMessageToTxnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AsyncProducerMock.AddMessageToTxn at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddMessageToTxnCounter := mm_atomic.LoadUint64(&m.afterAddMessageToTxnCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddMessageToTxnMock.defaultExpectation != nil && afterAddMessageToTxnCounter < 1 {
		if m.AddMessageToTxnMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AsyncProducerMock.AddMessageToTxn at\n%s", m.AddMessageToTxnMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AsyncProducerMock.AddMessageToTxn at\n%s with params: %#v", m.AddMessageToTxnMock.defaultExpectation.expectationOrigins.origin, *m.AddMessageToTxnMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddMessageToTxn != nil && afterAddMessageToTxnCounter < 1 {
		m.t.Errorf("Expected call to AsyncProducerMock.AddMessageToTxn at\n%s", m.funcAddMessageToTxnOrigin)
	}

	if !m.AddMessageToTxnMock.invocationsDone() && afterAddMessageToTxnCounter > 0 {
		m.t.Errorf("Expected %d calls to AsyncProducerMock.AddMessageToTxn at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddMessageToTxnMock.expectedInvocations), m.AddMessageToTxnMock.expectedInvocationsOrigin, afterAddMessageToTxnCounter)
	}
}

type mAsyncProducerMockAddOffsetsToTxn struct {
	optional           bool
	mock               *AsyncProducerMock
	defaultExpectation *AsyncProducerMockAddOffsetsToTxnExpectation
	expectations       []*AsyncProducerMockAddOffsetsToTxnExpectation

	callArgs []*AsyncProducerMockAddOffsetsToTxnParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AsyncProducerMockAddOffsetsToTxnExpectation specifies expectation struct of the AsyncProducer.AddOffsetsToTxn
type AsyncProducerMockAddOffsetsToTxnExpectation struct {
	mock               *AsyncProducerMock
	params             *AsyncProducerMockAddOffsetsToTxnParams
	paramPtrs          *AsyncProducerMockAddOffsetsToTxnParamPtrs
	expectationOrigins AsyncProducerMockAddOffsetsToTxnExpectationOrigins
	results            *AsyncProducerMockAddOffsetsToTxnResults
	returnOrigin       string
	Counter            uint64
}

// AsyncProducerMockAddOffsetsToTxnParams contains parameters of the AsyncProducer.AddOffsetsToTxn
type AsyncProducerMockAddOffsetsToTxnParams struct {
	offsets map[string][]*mm_sarama.PartitionOffsetMetadata
	groupId string
}

// AsyncProducerMockAddOffsetsToTxnParamPtrs contains pointers to parameters of the AsyncProducer.AddOffsetsToTxn
type AsyncProducerMockAddOffsetsToTxnParamPtrs struct {
	offsets *map[string][]*mm_sarama.PartitionOffsetMetadata
	groupId *string
}

// AsyncProducerMockAddOffsetsToTxnResults contains results of the AsyncProducer.AddOffsetsToTxn
type AsyncProducerMockAddOffsetsToTxnResults struct {
	err error
}

// AsyncProducerMockAddOffsetsToTxnOrigins contains origins of expectations of the AsyncProducer.AddOffsetsToTxn
type AsyncProducerMockAddOffsetsToTxnExpectationOrigins struct {
	origin        string
	originOffsets string
	originGroupId string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddOffsetsToTxn *mAsyncProducerMockAddOffsetsToTxn) Optional() *mAsyncProducerMockAddOffsetsToTxn {
	mmAddOffsetsToTxn.optional = true
	return mmAddOffsetsToTxn
}

// Expect sets up expected params for AsyncProducer.AddOffsetsToTxn
func (mmAddOffsetsToTxn *mAsyncProducerMockAddOffsetsToTxn) Expect(offsets map[string][]*mm_sarama.PartitionOffsetMetadata, groupId string) *mAsyncProducerMockAddOffsetsToTxn {
	if mmAddOffsetsToTxn.mock.funcAddOffsetsToTxn != nil {
		mmAddOffsetsToTxn.mock.t.Fatalf("AsyncProducerMock.AddOffsetsToTxn mock is already set by Set")
	}

	if mmAddOffsetsToTxn.defaultExpectation == nil {
		mmAddOffsetsToTxn.defaultExpectation = &AsyncProducerMockAddOffsetsToTxnExpectation{}
	}

	if mmAddOffsetsToTxn.defaultExpectation.paramPtrs != nil {
		mmAddOffsetsToTxn.mock.t.Fatalf("AsyncProducerMock.AddOffsetsToTxn mock is already set by ExpectParams functions")
	}

	mmAddOffsetsToTxn.defaultExpectation.params = &AsyncProducerMockAddOffsetsToTxnParams{offsets, groupId}
	mmAddOffsetsToTxn.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddOffsetsToTxn.expectations {
		if minimock.Equal(e.params, mmAddOffsetsToTxn.defaultExpectation.params) {
			mmAddOffsetsToTxn.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddOffsetsToTxn.defaultExpectation.params)
		}
	}

	return mmAddOffsetsToTxn
}

// ExpectOffsetsParam1 sets up expected param offsets for AsyncProducer.AddOffsetsToTxn
func (mmAddOffsetsToTxn *mAsyncProducerMockAddOffsetsToTxn) ExpectOffsetsParam1(offsets map[string][]*mm_sarama.PartitionOffsetMetadata) *mAsyncProducerMockAddOffsetsToTxn {
	if mmAddOffsetsToTxn.mock.funcAddOffsetsToTxn != nil {
		mmAddOffsetsToTxn.mock.t.Fatalf("AsyncProducerMock.AddOffsetsToTxn mock is already set by Set")
	}

	if mmAddOffsetsToTxn.defaultExpectation == nil {
		mmAddOffsetsToTxn.defaultExpectation = &AsyncProducerMockAddOffsetsToTxnExpectation{}
	}

	if mmAddOffsetsToTxn.defaultExpectation.params != nil {
		mmAddOffsetsToTxn.mock.t.Fatalf("AsyncProducerMock.AddOffsetsToTxn mock is already set by Expect")
	}

	if mmAddOffsetsToTxn.defaultExpectation.paramPtrs == nil {
		mmAddOffsetsToTxn.defaultExpectation.paramPtrs = &AsyncProducerMockAddOffsetsToTxnParamPtrs{}
	}
	mmAddOffsetsToTxn.defaultExpectation.paramPtrs.offsets = &offsets
	mmAddOffsetsToTxn.defaultExpectation.expectationOrigins.originOffsets = minimock.CallerInfo(1)

	return mmAddOffsetsToTxn
}

// ExpectGroupIdParam2 sets up expected param groupId for AsyncProducer.AddOffsetsToTxn
func (mmAddOffsetsToTxn *mAsyncProducerMockAddOffsetsToTxn) ExpectGroupIdParam2(groupId string) *mAsyncProducerMockAddOffsetsToTxn {
	if mmAddOffsetsToTxn.mock.funcAddOffsetsToTxn != nil {
		mmAddOffsetsToTxn.mock.t.Fatalf("AsyncProducerMock.AddOffsetsToTxn mock is already set by Set")
	}

	if mmAddOffsetsToTxn.defaultExpectation == nil {
		mmAddOffsetsToTxn.defaultExpectation = &AsyncProducerMockAddOffsetsToTxnExpectation{}
	}

	if mmAddOffsetsToTxn.defaultExpectation.params != nil {
		mmAddOffsetsToTxn.mock.t.Fatalf("AsyncProducerMock.AddOffsetsToTxn mock is already set by Expect")
	}

	if mmAddOffsetsToTxn.defaultExpectation.paramPtrs == nil {
		mmAddOffsetsToTxn.defaultExpectation.paramPtrs = &AsyncProducerMockAddOffsetsToTxnParamPtrs{}
	}
	mmAddOffsetsToTxn.defaultExpectation.paramPtrs.groupId = &groupId
	mmAddOffsetsToTxn.defaultExpectation.expectationOrigins.originGroupId = minimock.CallerInfo(1)

	return mmAddOffsetsToTxn
}

// Inspect accepts an inspector function that has same arguments as the AsyncProducer.AddOffsetsToTxn
func (mmAddOffsetsToTxn *mAsyncProducerMockAddOffsetsToTxn) Inspect(f func(offsets map[string][]*mm_sarama.PartitionOffsetMetadata, groupId string)) *mAsyncProducerMockAddOffsetsToTxn {
	if mmAddOffsetsToTxn.mock.inspectFuncAddOffsetsToTxn != nil {
		mmAddOffsetsToTxn.mock.t.Fatalf("Inspect function is already set for AsyncProducerMock.AddOffsetsToTxn")
	}

	mmAddOffsetsToTxn.mock.inspectFuncAddOffsetsToTxn = f

	return mmAddOffsetsToTxn
}

// Return sets up results that will be returned by AsyncProducer.AddOffsetsToTxn
func (mmAddOffsetsToTxn *mAsyncProducerMockAddOffsetsToTxn) Return(err error) *AsyncProducerMock {
	if mmAddOffsetsToTxn.mock.funcAddOffsetsToTxn != nil {
		mmAddOffsetsToTxn.mock.t.Fatalf("AsyncProducerMock.AddOffsetsToTxn mock is already set by Set")
	}

	if mmAddOffsetsToTxn.defaultExpectation == nil {
		mmAddOffsetsToTxn.defaultExpectation = &AsyncProducerMockAddOffsetsToTxnExpectation{mock: mmAddOffsetsToTxn.mock}
	}
	mmAddOffsetsToTxn.defaultExpectation.results = &AsyncProducerMockAddOffsetsToTxnResults{err}
	mmAddOffsetsToTxn.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddOffsetsToTxn.mock
}

// Set uses given function f to mock the AsyncProducer.AddOffsetsToTxn method
func (mmAddOffsetsToTxn *mAsyncProducerMockAddOffsetsToTxn) Set(f func(offsets map[string][]*mm_sarama.PartitionOffsetMetadata, groupId string) (err error)) *AsyncProducerMock {
	if mmAddOffsetsToTxn.defaultExpectation != nil {
		mmAddOffsetsToTxn.mock.t.Fatalf("Default expectation is already set for the AsyncProducer.AddOffsetsToTxn method")
	}

	if len(mmAddOffsetsToTxn.expectations) > 0 {
		mmAddOffsetsToTxn.mock.t.Fatalf("Some expectations are already set for the AsyncProducer.AddOffsetsToTxn method")
	}

	mmAddOffsetsToTxn.mock.funcAddOffsetsToTxn = f
	mmAddOffsetsToTxn.mock.funcAddOffsetsToTxnOrigin = minimock.CallerInfo(1)
	return mmAddOffsetsToTxn.mock
}

// When sets expectation for the AsyncProducer.AddOffsetsToTxn which will trigger the result defined by the following
// Then helper
func (mmAddOffsetsToTxn *mAsyncProducerMockAddOffsetsToTxn) When(offsets map[string][]*mm_sarama.PartitionOffsetMetadata, groupId string) *AsyncProducerMockAddOffsetsToTxnExpectation {
	if mmAddOffsetsToTxn.mock.funcAddOffsetsToTxn != nil {
		mmAddOffsetsToTxn.mock.t.Fatalf("AsyncProducerMock.AddOffsetsToTxn mock is already set by Set")
	}

	expectation := &AsyncProducerMockAddOffsetsToTxnExpectation{
		mock:               mmAddOffsetsToTxn.mock,
		params:             &AsyncProducerMockAddOffsetsToTxnParams{offsets, groupId},
		expectationOrigins: AsyncProducerMockAddOffsetsToTxnExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddOffsetsToTxn.expectations = append(mmAddOffsetsToTxn.expectations, expectation)
	return expectation
}

// Then sets up AsyncProducer.AddOffsetsToTxn return parameters for the expectation previously defined by the When method
func (e *AsyncProducerMockAddOffsetsToTxnExpectation) Then(err error) *AsyncProducerMock {
	e.results = &AsyncProducerMockAddOffsetsToTxnResults{err}
	return e.mock
}

// Times sets number of times AsyncProducer.AddOffsetsToTxn should be invoked
func (mmAddOffsetsToTxn *mAsyncProducerMockAddOffsetsToTxn) Times(n uint64) *mAsyncProducerMockAddOffsetsToTxn {
	if n == 0 {
		mmAddOffsetsToTxn.mock.t.Fatalf("Times of AsyncProducerMock.AddOffsetsToTxn mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddOffsetsToTxn.expectedInvocations, n)
	mmAddOffsetsToTxn.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddOffsetsToTxn
}

func (mmAddOffsetsToTxn *mAsyncProducerMockAddOffsetsToTxn) invocationsDone() bool {
	if len(mmAddOffsetsToTxn.expectations) == 0 && mmAddOffsetsToTxn.defaultExpectation == nil && mmAddOffsetsToTxn.mock.funcAddOffsetsToTxn == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddOffsetsToTxn.mock.afterAddOffsetsToTxnCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddOffsetsToTxn.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddOffsetsToTxn implements mm_sarama.AsyncProducer
func (mmAddOffsetsToTxn *AsyncProducerMock) AddOffsetsToTxn(offsets map[string][]*mm_sarama.PartitionOffsetMetadata, groupId string) (err error) {
	mm_atomic.AddUint64(&mmAddOffsetsToTxn.beforeAddOffsetsToTxnCounter, 1)
	defer mm_atomic.AddUint64(&mmAddOffsetsToTxn.afterAddOffsetsToTxnCounter, 1)

	mmAddOffsetsToTxn.t.Helper()

	if mmAddOffsetsToTxn.inspectFuncAddOffsetsToTxn != nil {
		mmAddOffsetsToTxn.inspectFuncAddOffsetsToTxn(offsets, groupId)
	}

	mm_params := AsyncProducerMockAddOffsetsToTxnParams{offsets, groupId}

	// Record call args
	mmAddOffsetsToTxn.AddOffsetsToTxnMock.mutex.Lock()
	mmAddOffsetsToTxn.AddOffsetsToTxnMock.callArgs = append(mmAddOffsetsToTxn.AddOffsetsToTxnMock.callArgs, &mm_params)
	mmAddOffsetsToTxn.AddOffsetsToTxnMock.mutex.Unlock()

	for _, e := range mmAddOffsetsToTxn.AddOffsetsToTxnMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddOffsetsToTxn.AddOffsetsToTxnMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddOffsetsToTxn.AddOffsetsToTxnMock.defaultExpectation.Counter, 1)
		mm_want := mmAddOffsetsToTxn.AddOffsetsToTxnMock.defaultExpectation.params
		mm_want_ptrs := mmAddOffsetsToTxn.AddOffsetsToTxnMock.defaultExpectation.paramPtrs

		mm_got := AsyncProducerMockAddOffsetsToTxnParams{offsets, groupId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.offsets != nil && !minimock.Equal(*mm_want_ptrs.offsets, mm_got.offsets) {
				mmAddOffsetsToTxn.t.Errorf("AsyncProducerMock.AddOffsetsToTxn got unexpected parameter offsets, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddOffsetsToTxn.AddOffsetsToTxnMock.defaultExpectation.expectationOrigins.originOffsets, *mm_want_ptrs.offsets, mm_got.offsets, minimock.Diff(*mm_want_ptrs.offsets, mm_got.offsets))
			}

			if mm_want_ptrs.groupId != nil && !minimock.Equal(*mm_want_ptrs.groupId, mm_got.groupId) {
				mmAddOffsetsToTxn.t.Errorf("AsyncProducerMock.AddOffsetsToTxn got unexpected parameter groupId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddOffsetsToTxn.AddOffsetsToTxnMock.defaultExpectation.expectationOrigins.originGroupId, *mm_want_ptrs.groupId, mm_got.groupId, minimock.Diff(*mm_want_ptrs.groupId, mm_got.groupId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddOffsetsToTxn.t.Errorf("AsyncProducerMock.AddOffsetsToTxn got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddOffsetsToTxn.AddOffsetsToTxnMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddOffsetsToTxn.AddOffsetsToTxnMock.defaultExpectation.results
		if mm_results == nil {
			mmAddOffsetsToTxn.t.Fatal("No results are set for the AsyncProducerMock.AddOffsetsToTxn")
		}
		return (*mm_results).err
	}
	if mmAddOffsetsToTxn.funcAddOffsetsToTxn != nil {
		return mmAddOffsetsToTxn.funcAddOffsetsToTxn(offsets, groupId)
	}
	mmAddOffsetsToTxn.t.Fatalf("Unexpected call to AsyncProducerMock.AddOffsetsToTxn. %v %v", offsets, groupId)
	return
}

// AddOffsetsToTxnAfterCounter returns a count of finished AsyncProducerMock.AddOffsetsToTxn invocations
func (mmAddOffsetsToTxn *AsyncProducerMock) AddOffsetsToTxnAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddOffsetsToTxn.afterAddOffsetsToTxnCounter)
}

// AddOffsetsToTxnBeforeCounter returns a count of AsyncProducerMock.AddOffsetsToTxn invocations
func (mmAddOffsetsToTxn *AsyncProducerMock) AddOffsetsToTxnBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddOffsetsToTxn.beforeAddOffsetsToTxnCounter)
}

// Calls returns a list of arguments used in each call to AsyncProducerMock.AddOffsetsToTxn.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddOffsetsToTxn *mAsyncProducerMockAddOffsetsToTxn) Calls() []*AsyncProducerMockAddOffsetsToTxnParams {
	mmAddOffsetsToTxn.mutex.RLock()

	argCopy := make([]*AsyncProducerMockAddOffsetsToTxnParams, len(mmAddOffsetsToTxn.callArgs))
	copy(argCopy, mmAddOffsetsToTxn.callArgs)

	mmAddOffsetsToTxn.mutex.RUnlock()

	return argCopy
}

// MinimockAddOffsetsToTxnDone returns true if the count of the AddOffsetsToTxn invocations corresponds
// the number of defined expectations
func (m *AsyncProducerMock) MinimockAddOffsetsToTxnDone() bool {
	if m.AddOffsetsToTxnMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddOffsetsToTxnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddOffsetsToTxnMock.invocationsDone()
}

// MinimockAddOffsetsToTxnInspect logs each unmet expectation
func (m *AsyncProducerMock) MinimockAddOffsetsToTxnInspect() {
	for _, e := range m.AddOffsetsToTxnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AsyncProducerMock.AddOffsetsToTxn at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddOffsetsToTxnCounter := mm_atomic.LoadUint64(&m.afterAddOffsetsToTxnCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddOffsetsToTxnMock.defaultExpectation != nil && afterAddOffsetsToTxnCounter < 1 {
		if m.AddOffsetsToTxnMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AsyncProducerMock.AddOffsetsToTxn at\n%s", m.AddOffsetsToTxnMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AsyncProducerMock.AddOffsetsToTxn at\n%s with params: %#v", m.AddOffsetsToTxnMock.defaultExpectation.expectationOrigins.origin, *m.AddOffsetsToTxnMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddOffsetsToTxn != nil && afterAddOffsetsToTxnCounter < 1 {
		m.t.Errorf("Expected call to AsyncProducerMock.AddOffsetsToTxn at\n%s", m.funcAddOffsetsToTxnOrigin)
	}

	if !m.AddOffsetsToTxnMock.invocationsDone() && afterAddOffsetsToTxnCounter > 0 {
		m.t.Errorf("Expected %d calls to AsyncProducerMock.AddOffsetsToTxn at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddOffsetsToTxnMock.expectedInvocations), m.AddOffsetsToTxnMock.expectedInvocationsOrigin, afterAddOffsetsToTxnCounter)
	}
}

type mAsyncProducerMockAsyncClose struct {
	optional           bool
	mock               *AsyncProducerMock
	defaultExpectation *AsyncProducerMockAsyncCloseExpectation
	expectations       []*AsyncProducerMockAsyncCloseExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AsyncProducerMockAsyncCloseExpectation specifies expectation struct of the AsyncProducer.AsyncClose
type AsyncProducerMockAsyncCloseExpectation struct {
	mock *AsyncProducerMock

	returnOrigin string
	Counter      uint64
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAsyncClose *mAsyncProducerMockAsyncClose) Optional() *mAsyncProducerMockAsyncClose {
	mmAsyncClose.optional = true
	return mmAsyncClose
}

// Expect sets up expected params for AsyncProducer.AsyncClose
func (mmAsyncClose *mAsyncProducerMockAsyncClose) Expect() *mAsyncProducerMockAsyncClose {
	if mmAsyncClose.mock.funcAsyncClose != nil {
		mmAsyncClose.mock.t.Fatalf("AsyncProducerMock.AsyncClose mock is already set by Set")
	}

	if mmAsyncClose.defaultExpectation == nil {
		mmAsyncClose.defaultExpectation = &AsyncProducerMockAsyncCloseExpectation{}
	}

	return mmAsyncClose
}

// Inspect accepts an inspector function that has same arguments as the AsyncProducer.AsyncClose
func (mmAsyncClose *mAsyncProducerMockAsyncClose) Inspect(f func()) *mAsyncProducerMockAsyncClose {
	if mmAsyncClose.mock.inspectFuncAsyncClose != nil {
		mmAsyncClose.mock.t.Fatalf("Inspect function is already set for AsyncProducerMock.AsyncClose")
	}

	mmAsyncClose.mock.inspectFuncAsyncClose = f

	return mmAsyncClose
}

// Return sets up results that will be returned by AsyncProducer.AsyncClose
func (mmAsyncClose *mAsyncProducerMockAsyncClose) Return() *AsyncProducerMock {
	if mmAsyncClose.mock.funcAsyncClose != nil {
		mmAsyncClose.mock.t.Fatalf("AsyncProducerMock.AsyncClose mock is already set by Set")
	}

	if mmAsyncClose.defaultExpectation == nil {
		mmAsyncClose.defaultExpectation = &AsyncProducerMockAsyncCloseExpectation{mock: mmAsyncClose.mock}
	}

	mmAsyncClose.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAsyncClose.mock
}

// Set uses given function f to mock the AsyncProducer.AsyncClose method
func (mmAsyncClose *mAsyncProducerMockAsyncClose) Set(f func()) *AsyncProducerMock {
	if mmAsyncClose.defaultExpectation != nil {
		mmAsyncClose.mock.t.Fatalf("Default expectation is already set for the AsyncProducer.AsyncClose method")
	}

	if len(mmAsyncClose.expectations) > 0 {
		mmAsyncClose.mock.t.Fatalf("Some expectations are already set for the AsyncProducer.AsyncClose method")
	}

	mmAsyncClose.mock.funcAsyncClose = f
	mmAsyncClose.mock.funcAsyncCloseOrigin = minimock.CallerInfo(1)
	return mmAsyncClose.mock
}

// Times sets number of times AsyncProducer.AsyncClose should be invoked
func (mmAsyncClose *mAsyncProducerMockAsyncClose) Times(n uint64) *mAsyncProducerMockAsyncClose {
	if n == 0 {
		mmAsyncClose.mock.t.Fatalf("Times of AsyncProducerMock.AsyncClose mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAsyncClose.expectedInvocations, n)
	mmAsyncClose.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAsyncClose
}

func (mmAsyncClose *mAsyncProducerMockAsyncClose) invocationsDone() bool {
	if len(mmAsyncClose.expectations) == 0 && mmAsyncClose.defaultExpectation == nil && mmAsyncClose.mock.funcAsyncClose == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAsyncClose.mock.afterAsyncCloseCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAsyncClose.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AsyncClose implements mm_sarama.AsyncProducer
func (mmAsyncClose *AsyncProducerMock) AsyncClose() {
	mm_atomic.AddUint64(&mmAsyncClose.beforeAsyncCloseCounter, 1)
	defer mm_atomic.AddUint64(&mmAsyncClose.afterAsyncCloseCounter, 1)

	mmAsyncClose.t.Helper()

	if mmAsyncClose.inspectFuncAsyncClose != nil {
		mmAsyncClose.inspectFuncAsyncClose()
	}

	if mmAsyncClose.AsyncCloseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAsyncClose.AsyncCloseMock.defaultExpectation.Counter, 1)

		return

	}
	if mmAsyncClose.funcAsyncClose != nil {
		mmAsyncClose.funcAsyncClose()
		return
	}
	mmAsyncClose.t.Fatalf("Unexpected call to AsyncProducerMock.AsyncClose.")

}

// AsyncCloseAfterCounter returns a count of finished AsyncProducerMock.AsyncClose invocations
func (mmAsyncClose *AsyncProducerMock) AsyncCloseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAsyncClose.afterAsyncCloseCounter)
}

// AsyncCloseBeforeCounter returns a count of AsyncProducerMock.AsyncClose invocations
func (mmAsyncClose *AsyncProducerMock) AsyncCloseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAsyncClose.beforeAsyncCloseCounter)
}

// MinimockAsyncCloseDone returns true if the count of the AsyncClose invocations corresponds
// the number of defined expectations
func (m *AsyncProducerMock) MinimockAsyncCloseDone() bool {
	if m.AsyncCloseMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AsyncCloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AsyncCloseMock.invocationsDone()
}

// MinimockAsyncCloseInspect logs each unmet expectation
func (m *AsyncProducerMock) MinimockAsyncCloseInspect() {
	for _, e := range m.AsyncCloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to AsyncProducerMock.AsyncClose")
		}
	}

	afterAsyncCloseCounter := mm_atomic.LoadUint64(&m.afterAsyncCloseCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AsyncCloseMock.defaultExpectation != nil && afterAsyncCloseCounter < 1 {
		m.t.Errorf("Expected call to AsyncProducerMock.AsyncClose at\n%s", m.AsyncCloseMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAsyncClose != nil && afterAsyncCloseCounter < 1 {
		m.t.Errorf("Expected call to AsyncProducerMock.AsyncClose at\n%s", m.funcAsyncCloseOrigin)
	}

	if !m.AsyncCloseMock.invocationsDone() && afterAsyncCloseCounter > 0 {
		m.t.Errorf("Expected %d calls to AsyncProducerMock.AsyncClose at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AsyncCloseMock.expectedInvocations), m.AsyncCloseMock.expectedInvocationsOrigin, afterAsyncCloseCounter)
	}
}

type mAsyncProducerMockBeginTxn struct {
	optional           bool
	mock               *AsyncProducerMock
	defaultExpectation *AsyncProducerMockBeginTxnExpectation
	expectations       []*AsyncProducerMockBeginTxnExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AsyncProducerMockBeginTxnExpectation specifies expectation struct of the AsyncProducer.BeginTxn
type AsyncProducerMockBeginTxnExpectation struct {
	mock *AsyncProducerMock

	results      *AsyncProducerMockBeginTxnResults
	returnOrigin string
	Counter      uint64
}

// AsyncProducerMockBeginTxnResults contains results of the AsyncProducer.BeginTxn
type AsyncProducerMockBeginTxnResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmBeginTxn *mAsyncProducerMockBeginTxn) Optional() *mAsyncProducerMockBeginTxn {
	mmBeginTxn.optional = true
	return mmBeginTxn
}

// Expect sets up expected params for AsyncProducer.BeginTxn
func (mmBeginTxn *mAsyncProducerMockBeginTxn) Expect() *mAsyncProducerMockBeginTxn {
	if mmBeginTxn.mock.funcBeginTxn != nil {
		mmBeginTxn.mock.t.Fatalf("AsyncProducerMock.BeginTxn mock is already set by Set")
	}

	if mmBeginTxn.defaultExpectation == nil {
		mmBeginTxn.defaultExpectation = &AsyncProducerMockBeginTxnExpectation{}
	}

	return mmBeginTxn
}

// Inspect accepts an inspector function that has same arguments as the AsyncProducer.BeginTxn
func (mmBeginTxn *mAsyncProducerMockBeginTxn) Inspect(f func()) *mAsyncProducerMockBeginTxn {
	if mmBeginTxn.mock.inspectFuncBeginTxn != nil {
		mmBeginTxn.mock.t.Fatalf("Inspect function is already set for AsyncProducerMock.BeginTxn")
	}

	mmBeginTxn.mock.inspectFuncBeginTxn = f

	return mmBeginTxn
}

// Return sets up results that will be returned by AsyncProducer.BeginTxn
func (mmBeginTxn *mAsyncProducerMockBeginTxn) Return(err error) *AsyncProducerMock {
	if mmBeginTxn.mock.funcBeginTxn != nil {
		mmBeginTxn.mock.t.Fatalf("AsyncProducerMock.BeginTxn mock is already set by Set")
	}

	if mmBeginTxn.defaultExpectation == nil {
		mmBeginTxn.defaultExpectation = &AsyncProducerMockBeginTxnExpectation{mock: mmBeginTxn.mock}
	}
	mmBeginTxn.defaultExpectation.results = &AsyncProducerMockBeginTxnResults{err}
	mmBeginTxn.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmBeginTxn.mock
}

// Set uses given function f to mock the AsyncProducer.BeginTxn method
func (mmBeginTxn *mAsyncProducerMockBeginTxn) Set(f func() (err error)) *AsyncProducerMock {
	if mmBeginTxn.defaultExpectation != nil {
		mmBeginTxn.mock.t.Fatalf("Default expectation is already set for the AsyncProducer.BeginTxn method")
	}

	if len(mmBeginTxn.expectations) > 0 {
		mmBeginTxn.mock.t.Fatalf("Some expectations are already set for the AsyncProducer.BeginTxn method")
	}

	mmBeginTxn.mock.funcBeginTxn = f
	mmBeginTxn.mock.funcBeginTxnOrigin = minimock.CallerInfo(1)
	return mmBeginTxn.mock
}

// Times sets number of times AsyncProducer.BeginTxn should be invoked
func (mmBeginTxn *mAsyncProducerMockBeginTxn) Times(n uint64) *mAsyncProducerMockBeginTxn {
	if n == 0 {
		mmBeginTxn.mock.t.Fatalf("Times of AsyncProducerMock.BeginTxn mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmBeginTxn.expectedInvocations, n)
	mmBeginTxn.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmBeginTxn
}

func (mmBeginTxn *mAsyncProducerMockBeginTxn) invocationsDone() bool {
	if len(mmBeginTxn.expectations) == 0 && mmBeginTxn.defaultExpectation == nil && mmBeginTxn.mock.funcBeginTxn == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmBeginTxn.mock.afterBeginTxnCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmBeginTxn.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// BeginTxn implements mm_sarama.AsyncProducer
func (mmBeginTxn *AsyncProducerMock) BeginTxn() (err error) {
	mm_atomic.AddUint64(&mmBeginTxn.beforeBeginTxnCounter, 1)
	defer mm_atomic.AddUint64(&mmBeginTxn.afterBeginTxnCounter, 1)

	mmBeginTxn.t.Helper()

	if mmBeginTxn.inspectFuncBeginTxn != nil {
		mmBeginTxn.inspectFuncBeginTxn()
	}

	if mmBeginTxn.BeginTxnMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmBeginTxn.BeginTxnMock.defaultExpectation.Counter, 1)

		mm_results := mmBeginTxn.BeginTxnMock.defaultExpectation.results
		if mm_results == nil {
			mmBeginTxn.t.Fatal("No results are set for the AsyncProducerMock.BeginTxn")
		}
		return (*mm_results).err
	}
	if mmBeginTxn.funcBeginTxn != nil {
		return mmBeginTxn.funcBeginTxn()
	}
	mmBeginTxn.t.Fatalf("Unexpected call to AsyncProducerMock.BeginTxn.")
	return
}

// BeginTxnAfterCounter returns a count of finished AsyncProducerMock.BeginTxn invocations
func (mmBeginTxn *AsyncProducerMock) BeginTxnAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBeginTxn.afterBeginTxnCounter)
}

// BeginTxnBeforeCounter returns a count of AsyncProducerMock.BeginTxn invocations
func (mmBeginTxn *AsyncProducerMock) BeginTxnBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBeginTxn.beforeBeginTxnCounter)
}

// MinimockBeginTxnDone returns true if the count of the BeginTxn invocations corresponds
// the number of defined expectations
func (m *AsyncProducerMock) MinimockBeginTxnDone() bool {
	if m.BeginTxnMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.BeginTxnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.BeginTxnMock.invocationsDone()
}

// MinimockBeginTxnInspect logs each unmet expectation
func (m *AsyncProducerMock) MinimockBeginTxnInspect() {
	for _, e := range m.BeginTxnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to AsyncProducerMock.BeginTxn")
		}
	}

	afterBeginTxnCounter := mm_atomic.LoadUint64(&m.afterBeginTxnCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.BeginTxnMock.defaultExpectation != nil && afterBeginTxnCounter < 1 {
		m.t.Errorf("Expected call to AsyncProducerMock.BeginTxn at\n%s", m.BeginTxnMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBeginTxn != nil && afterBeginTxnCounter < 1 {
		m.t.Errorf("Expected call to AsyncProducerMock.BeginTxn at\n%s", m.funcBeginTxnOrigin)
	}

	if !m.BeginTxnMock.invocationsDone() && afterBeginTxnCounter > 0 {
		m.t.Errorf("Expected %d calls to AsyncProducerMock.BeginTxn at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.BeginTxnMock.expectedInvocations), m.BeginTxnMock.expectedInvocationsOrigin, afterBeginTxnCounter)
	}
}

type mAsyncProducerMockClose struct {
	optional           bool
	mock               *AsyncProducerMock
	defaultExpectation *AsyncProducerMockCloseExpectation
	expectations       []*AsyncProducerMockCloseExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AsyncProducerMockCloseExpectation specifies expectation struct of the AsyncProducer.Close
type AsyncProducerMockCloseExpectation struct {
	mock *AsyncProducerMock

	results      *AsyncProducerMockCloseResults
	returnOrigin string
	Counter      uint64
}

// AsyncProducerMockCloseResults contains results of the AsyncProducer.Close
type AsyncProducerMockCloseResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmClose *mAsyncProducerMockClose) Optional() *mAsyncProducerMockClose {
	mmClose.optional = true
	return mmClose
}

// Expect sets up expected params for AsyncProducer.Close
func (mmClose *mAsyncProducerMockClose) Expect() *mAsyncProducerMockClose {
	if mmClose.mock.funcClose != nil {
		mmClose.mock.t.Fatalf("AsyncProducerMock.Close mock is already set by Set")
	}

	if mmClose.defaultExpectation == nil {
		mmClose.defaultExpectation = &AsyncProducerMockCloseExpectation{}
	}

	return mmClose
}

// Inspect accepts an inspector function that has same arguments as the AsyncProducer.Close
func (mmClose *mAsyncProducerMockClose) Inspect(f func()) *mAsyncProducerMockClose {
	if mmClose.mock.inspectFuncClose != nil {
		mmClose.mock.t.Fatalf("Inspect function is already set for AsyncProducerMock.Close")
	}

	mmClose.mock.inspectFuncClose = f

	return mmClose
}

// Return sets up results that will be returned by AsyncProducer.Close
func (mmClose *mAsyncProducerMockClose) Return(err error) *AsyncProducerMock {
	if mmClose.mock.funcClose != nil {
		mmClose.mock.t.Fatalf("AsyncProducerMock.Close mock is already set by Set")
	}

	if mmClose.defaultExpectation == nil {
		mmClose.defaultExpectation = &AsyncProducerMockCloseExpectation{mock: mmClose.mock}
	}
	mmClose.defaultExpectation.results = &AsyncProducerMockCloseResults{err}
	mmClose.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmClose.mock
}

// Set uses given function f to mock the AsyncProducer.Close method
func (mmClose *mAsyncProducerMockClose) Set(f func() (err error)) *AsyncProducerMock {
	if mmClose.defaultExpectation != nil {
		mmClose.mock.t.Fatalf("Default expectation is already set for the AsyncProducer.Close method")
	}

	if len(mmClose.expectations) > 0 {
		mmClose.mock.t.Fatalf("Some expectations are already set for the AsyncProducer.Close method")
	}

	mmClose.mock.funcClose = f
	mmClose.mock.funcCloseOrigin = minimock.CallerInfo(1)
	return mmClose.mock
}

// Times sets number of times AsyncProducer.Close should be invoked
func (mmClose *mAsyncProducerMockClose) Times(n uint64) *mAsyncProducerMockClose {
	if n == 0 {
		mmClose.mock.t.Fatalf("Times of AsyncProducerMock.Close mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmClose.expectedInvocations, n)
	mmClose.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmClose
}

func (mmClose *mAsyncProducerMockClose) invocationsDone() bool {
	if len(mmClose.expectations) == 0 && mmClose.defaultExpectation == nil && mmClose.mock.funcClose == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmClose.mock.afterCloseCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmClose.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Close implements mm_sarama.AsyncProducer
func (mmClose *AsyncProducerMock) Close() (err error) {
	mm_atomic.AddUint64(&mmClose.beforeCloseCounter, 1)
	defer mm_atomic.AddUint64(&mmClose.afterCloseCounter, 1)

	mmClose.t.Helper()

	if mmClose.inspectFuncClose != nil {
		mmClose.inspectFuncClose()
	}

	if mmClose.CloseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmClose.CloseMock.defaultExpectation.Counter, 1)

		mm_results := mmClose.CloseMock.defaultExpectation.results
		if mm_results == nil {
			mmClose.t.Fatal("No results are set for the AsyncProducerMock.Close")
		}
		return (*mm_results).err
	}
	if mmClose.funcClose != nil {
		return mmClose.funcClose()
	}
	mmClose.t.Fatalf("Unexpected call to AsyncProducerMock.Close.")
	return
}

// CloseAfterCounter returns a count of finished AsyncProducerMock.Close invocations
func (mmClose *AsyncProducerMock) CloseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClose.afterCloseCounter)
}

// CloseBeforeCounter returns a count of AsyncProducerMock.Close invocations
func (mmClose *AsyncProducerMock) CloseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClose.beforeCloseCounter)
}

// MinimockCloseDone returns true if the count of the Close invocations corresponds
// the number of defined expectations
func (m *AsyncProducerMock) MinimockCloseDone() bool {
	if m.CloseMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CloseMock.invocationsDone()
}

// MinimockCloseInspect logs each unmet expectation
func (m *AsyncProducerMock) MinimockCloseInspect() {
	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to AsyncProducerMock.Close")
		}
	}

	afterCloseCounter := mm_atomic.LoadUint64(&m.afterCloseCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CloseMock.defaultExpectation != nil && afterCloseCounter < 1 {
		m.t.Errorf("Expected call to AsyncProducerMock.Close at\n%s", m.CloseMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClose != nil && afterCloseCounter < 1 {
		m.t.Errorf("Expected call to AsyncProducerMock.Close at\n%s", m.funcCloseOrigin)
	}

	if !m.CloseMock.invocationsDone() && afterCloseCounter > 0 {
		m.t.Errorf("Expected %d calls to AsyncProducerMock.Close at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CloseMock.expectedInvocations), m.CloseMock.expectedInvocationsOrigin, afterCloseCounter)
	}
}

type mAsyncProducerMockCommitTxn struct {
	optional           bool
	mock               *AsyncProducerMock
	defaultExpectation *AsyncProducerMockCommitTxnExpectation
	expectations       []*AsyncProducerMockCommitTxnExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AsyncProducerMockCommitTxnExpectation specifies expectation struct of the AsyncProducer.CommitTxn
type AsyncProducerMockCommitTxnExpectation struct {
	mock *AsyncProducerMock

	results      *AsyncProducerMockCommitTxnResults
	returnOrigin string
	Counter      uint64
}

// AsyncProducerMockCommitTxnResults contains results of the AsyncProducer.CommitTxn
type AsyncProducerMockCommitTxnResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCommitTxn *mAsyncProducerMockCommitTxn) Optional() *mAsyncProducerMockCommitTxn {
	mmCommitTxn.optional = true
	return mmCommitTxn
}

// Expect sets up expected params for AsyncProducer.CommitTxn
func (mmCommitTxn *mAsyncProducerMockCommitTxn) Expect() *mAsyncProducerMockCommitTxn {
	if mmCommitTxn.mock.funcCommitTxn != nil {
		mmCommitTxn.mock.t.Fatalf("AsyncProducerMock.CommitTxn mock is already set by Set")
	}

	if mmCommitTxn.defaultExpectation == nil {
		mmCommitTxn.defaultExpectation = &AsyncProducerMockCommitTxnExpectation{}
	}

	return mmCommitTxn
}

// Inspect accepts an inspector function that has same arguments as the AsyncProducer.CommitTxn
func (mmCommitTxn *mAsyncProducerMockCommitTxn) Inspect(f func()) *mAsyncProducerMockCommitTxn {
	if mmCommitTxn.mock.inspectFuncCommitTxn != nil {
		mmCommitTxn.mock.t.Fatalf("Inspect function is already set for AsyncProducerMock.CommitTxn")
	}

	mmCommitTxn.mock.inspectFuncCommitTxn = f

	return mmCommitTxn
}

// Return sets up results that will be returned by AsyncProducer.CommitTxn
func (mmCommitTxn *mAsyncProducerMockCommitTxn) Return(err error) *AsyncProducerMock {
	if mmCommitTxn.mock.funcCommitTxn != nil {
		mmCommitTxn.mock.t.Fatalf("AsyncProducerMock.CommitTxn mock is already set by Set")
	}

	if mmCommitTxn.defaultExpectation == nil {
		mmCommitTxn.defaultExpectation = &AsyncProducerMockCommitTxnExpectation{mock: mmCommitTxn.mock}
	}
	mmCommitTxn.defaultExpectation.results = &AsyncProducerMockCommitTxnResults{err}
	mmCommitTxn.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCommitTxn.mock
}

// Set uses given function f to mock the AsyncProducer.CommitTxn method
func (mmCommitTxn *mAsyncProducerMockCommitTxn) Set(f func() (err error)) *AsyncProducerMock {
	if mmCommitTxn.defaultExpectation != nil {
		mmCommitTxn.mock.t.Fatalf("Default expectation is already set for the AsyncProducer.CommitTxn method")
	}

	if len(mmCommitTxn.expectations) > 0 {
		mmCommitTxn.mock.t.Fatalf("Some expectations are already set for the AsyncProducer.CommitTxn method")
	}

	mmCommitTxn.mock.funcCommitTxn = f
	mmCommitTxn.mock.funcCommitTxnOrigin = minimock.CallerInfo(1)
	return mmCommitTxn.mock
}

// Times sets number of times AsyncProducer.CommitTxn should be invoked
func (mmCommitTxn *mAsyncProducerMockCommitTxn) Times(n uint64) *mAsyncProducerMockCommitTxn {
	if n == 0 {
		mmCommitTxn.mock.t.Fatalf("Times of AsyncProducerMock.CommitTxn mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCommitTxn.expectedInvocations, n)
	mmCommitTxn.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCommitTxn
}

func (mmCommitTxn *mAsyncProducerMockCommitTxn) invocationsDone() bool {
	if len(mmCommitTxn.expectations) == 0 && mmCommitTxn.defaultExpectation == nil && mmCommitTxn.mock.funcCommitTxn == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCommitTxn.mock.afterCommitTxnCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCommitTxn.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CommitTxn implements mm_sarama.AsyncProducer
func (mmCommitTxn *AsyncProducerMock) CommitTxn() (err error) {
	mm_atomic.AddUint64(&mmCommitTxn.beforeCommitTxnCounter, 1)
	defer mm_atomic.AddUint64(&mmCommitTxn.afterCommitTxnCounter, 1)

	mmCommitTxn.t.Helper()

	if mmCommitTxn.inspectFuncCommitTxn != nil {
		mmCommitTxn.inspectFuncCommitTxn()
	}

	if mmCommitTxn.CommitTxnMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCommitTxn.CommitTxnMock.defaultExpectation.Counter, 1)

		mm_results := mmCommitTxn.CommitTxnMock.defaultExpectation.results
		if mm_results == nil {
			mmCommitTxn.t.Fatal("No results are set for the AsyncProducerMock.CommitTxn")
		}
		return (*mm_results).err
	}
	if mmCommitTxn.funcCommitTxn != nil {
		return mmCommitTxn.funcCommitTxn()
	}
	mmCommitTxn.t.Fatalf("Unexpected call to AsyncProducerMock.CommitTxn.")
	return
}

// CommitTxnAfterCounter returns a count of finished AsyncProducerMock.CommitTxn invocations
func (mmCommitTxn *AsyncProducerMock) CommitTxnAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCommitTxn.afterCommitTxnCounter)
}

// CommitTxnBeforeCounter returns a count of AsyncProducerMock.CommitTxn invocations
func (mmCommitTxn *AsyncProducerMock) CommitTxnBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCommitTxn.beforeCommitTxnCounter)
}

// MinimockCommitTxnDone returns true if the count of the CommitTxn invocations corresponds
// the number of defined expectations
func (m *AsyncProducerMock) MinimockCommitTxnDone() bool {
	if m.CommitTxnMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CommitTxnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CommitTxnMock.invocationsDone()
}

// MinimockCommitTxnInspect logs each unmet expectation
func (m *AsyncProducerMock) MinimockCommitTxnInspect() {
	for _, e := range m.CommitTxnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to AsyncProducerMock.CommitTxn")
		}
	}

	afterCommitTxnCounter := mm_atomic.LoadUint64(&m.afterCommitTxnCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CommitTxnMock.defaultExpectation != nil && afterCommitTxnCounter < 1 {
		m.t.Errorf("Expected call to AsyncProducerMock.CommitTxn at\n%s", m.CommitTxnMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCommitTxn != nil && afterCommitTxnCounter < 1 {
		m.t.Errorf("Expected call to AsyncProducerMock.CommitTxn at\n%s", m.funcCommitTxnOrigin)
	}

	if !m.CommitTxnMock.invocationsDone() && afterCommitTxnCounter > 0 {
		m.t.Errorf("Expected %d calls to AsyncProducerMock.CommitTxn at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CommitTxnMock.expectedInvocations), m.CommitTxnMock.expectedInvocationsOrigin, afterCommitTxnCounter)
	}
}

type mAsyncProducerMockErrors struct {
	optional           bool
	mock               *AsyncProducerMock
	defaultExpectation *AsyncProducerMockErrorsExpectation
	expectations       []*AsyncProducerMockErrorsExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AsyncProducerMockErrorsExpectation specifies expectation struct of the AsyncProducer.Errors
type AsyncProducerMockErrorsExpectation struct {
	mock *AsyncProducerMock

	results      *AsyncProducerMockErrorsResults
	returnOrigin string
	Counter      uint64
}

// AsyncProducerMockErrorsResults contains results of the AsyncProducer.Errors
type AsyncProducerMockErrorsResults struct {
	ch1 <-chan *mm_sarama.ProducerError
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmErrors *mAsyncProducerMockErrors) Optional() *mAsyncProducerMockErrors {
	mmErrors.optional = true
	return mmErrors
}

// Expect sets up expected params for AsyncProducer.Errors
func (mmErrors *mAsyncProducerMockErrors) Expect() *mAsyncProducerMockErrors {
	if mmErrors.mock.funcErrors != nil {
		mmErrors.mock.t.Fatalf("AsyncProducerMock.Errors mock is already set by Set")
	}

	if mmErrors.defaultExpectation == nil {
		mmErrors.defaultExpectation = &AsyncProducerMockErrorsExpectation{}
	}

	return mmErrors
}

// Inspect accepts an inspector function that has same arguments as the AsyncProducer.Errors
func (mmErrors *mAsyncProducerMockErrors) Inspect(f func()) *mAsyncProducerMockErrors {
	if mmErrors.mock.inspectFuncErrors != nil {
		mmErrors.mock.t.Fatalf("Inspect function is already set for AsyncProducerMock.Errors")
	}

	mmErrors.mock.inspectFuncErrors = f

	return mmErrors
}

// Return sets up results that will be returned by AsyncProducer.Errors
func (mmErrors *mAsyncProducerMockErrors) Return(ch1 <-chan *mm_sarama.ProducerError) *AsyncProducerMock {
	if mmErrors.mock.funcErrors != nil {
		mmErrors.mock.t.Fatalf("AsyncProducerMock.Errors mock is already set by Set")
	}

	if mmErrors.defaultExpectation == nil {
		mmErrors.defaultExpectation = &AsyncProducerMockErrorsExpectation{mock: mmErrors.mock}
	}
	mmErrors.defaultExpectation.results = &AsyncProducerMockErrorsResults{ch1}
	mmErrors.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmErrors.mock
}

// Set uses given function f to mock the AsyncProducer.Errors method
func (mmErrors *mAsyncProducerMockErrors) Set(f func() (ch1 <-chan *mm_sarama.ProducerError)) *AsyncProducerMock {
	if mmErrors.defaultExpectation != nil {
		mmErrors.mock.t.Fatalf("Default expectation is already set for the AsyncProducer.Errors method")
	}

	if len(mmErrors.expectations) > 0 {
		mmErrors.mock.t.Fatalf("Some expectations are already set for the AsyncProducer.Errors method")
	}

	mmErrors.mock.funcErrors = f
	mmErrors.mock.funcErrorsOrigin = minimock.CallerInfo(1)
	return mmErrors.mock
}

// Times sets number of times AsyncProducer.Errors should be invoked
func (mmErrors *mAsyncProducerMockErrors) Times(n uint64) *mAsyncProducerMockErrors {
	if n == 0 {
		mmErrors.mock.t.Fatalf("Times of AsyncProducerMock.Errors mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmErrors.expectedInvocations, n)
	mmErrors.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmErrors
}

func (mmErrors *mAsyncProducerMockErrors) invocationsDone() bool {
	if len(mmErrors.expectations) == 0 && mmErrors.defaultExpectation == nil && mmErrors.mock.funcErrors == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmErrors.mock.afterErrorsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmErrors.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Errors implements mm_sarama.AsyncProducer
func (mmErrors *AsyncProducerMock) Errors() (ch1 <-chan *mm_sarama.ProducerError) {
	mm_atomic.AddUint64(&mmErrors.beforeErrorsCounter, 1)
	defer mm_atomic.AddUint64(&mmErrors.afterErrorsCounter, 1)

	mmErrors.t.Helper()

	if mmErrors.inspectFuncErrors != nil {
		mmErrors.inspectFuncErrors()
	}

	if mmErrors.ErrorsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmErrors.ErrorsMock.defaultExpectation.Counter, 1)

		mm_results := mmErrors.ErrorsMock.defaultExpectation.results
		if mm_results == nil {
			mmErrors.t.Fatal("No results are set for the AsyncProducerMock.Errors")
		}
		return (*mm_results).ch1
	}
	if mmErrors.funcErrors != nil {
		return mmErrors.funcErrors()
	}
	mmErrors.t.Fatalf("Unexpected call to AsyncProducerMock.Errors.")
	return
}

// ErrorsAfterCounter returns a count of finished AsyncProducerMock.Errors invocations
func (mmErrors *AsyncProducerMock) ErrorsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmErrors.afterErrorsCounter)
}

// ErrorsBeforeCounter returns a count of AsyncProducerMock.Errors invocations
func (mmErrors *AsyncProducerMock) ErrorsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmErrors.beforeErrorsCounter)
}

// MinimockErrorsDone returns true if the count of the Errors invocations corresponds
// the number of defined expectations
func (m *AsyncProducerMock) MinimockErrorsDone() bool {
	if m.ErrorsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ErrorsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ErrorsMock.invocationsDone()
}

// MinimockErrorsInspect logs each unmet expectation
func (m *AsyncProducerMock) MinimockErrorsInspect() {
	for _, e := range m.ErrorsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to AsyncProducerMock.Errors")
		}
	}

	afterErrorsCounter := mm_atomic.LoadUint64(&m.afterErrorsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ErrorsMock.defaultExpectation != nil && afterErrorsCounter < 1 {
		m.t.Errorf("Expected call to AsyncProducerMock.Errors at\n%s", m.ErrorsMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcErrors != nil && afterErrorsCounter < 1 {
		m.t.Errorf("Expected call to AsyncProducerMock.Errors at\n%s", m.funcErrorsOrigin)
	}

	if !m.ErrorsMock.invocationsDone() && afterErrorsCounter > 0 {
		m.t.Errorf("Expected %d calls to AsyncProducerMock.Errors at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ErrorsMock.expectedInvocations), m.ErrorsMock.expectedInvocationsOrigin, afterErrorsCounter)
	}
}

type mAsyncProducerMockInput struct {
	optional           bool
	mock               *AsyncProducerMock
	defaultExpectation *AsyncProducerMockInputExpectation
	expectations       []*AsyncProducerMockInputExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AsyncProducerMockInputExpectation specifies expectation struct of the AsyncProducer.Input
type AsyncProducerMockInputExpectation struct {
	mock *AsyncProducerMock

	results      *AsyncProducerMockInputResults
	returnOrigin string
	Counter      uint64
}

// AsyncProducerMockInputResults contains results of the AsyncProducer.Input
type AsyncProducerMockInputResults struct {
	ch1 chan<- *mm_sarama.ProducerMessage
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmInput *mAsyncProducerMockInput) Optional() *mAsyncProducerMockInput {
	mmInput.optional = true
	return mmInput
}

// Expect sets up expected params for AsyncProducer.Input
func (mmInput *mAsyncProducerMockInput) Expect() *mAsyncProducerMockInput {
	if mmInput.mock.funcInput != nil {
		mmInput.mock.t.Fatalf("AsyncProducerMock.Input mock is already set by Set")
	}

	if mmInput.defaultExpectation == nil {
		mmInput.defaultExpectation = &AsyncProducerMockInputExpectation{}
	}

	return mmInput
}

// Inspect accepts an inspector function that has same arguments as the AsyncProducer.Input
func (mmInput *mAsyncProducerMockInput) Inspect(f func()) *mAsyncProducerMockInput {
	if mmInput.mock.inspectFuncInput != nil {
		mmInput.mock.t.Fatalf("Inspect function is already set for AsyncProducerMock.Input")
	}

	mmInput.mock.inspectFuncInput = f

	return mmInput
}

// Return sets up results that will be returned by AsyncProducer.Input
func (mmInput *mAsyncProducerMockInput) Return(ch1 chan<- *mm_sarama.ProducerMessage) *AsyncProducerMock {
	if mmInput.mock.funcInput != nil {
		mmInput.mock.t.Fatalf("AsyncProducerMock.Input mock is already set by Set")
	}

	if mmInput.defaultExpectation == nil {
		mmInput.defaultExpectation = &AsyncProducerMockInputExpectation{mock: mmInput.mock}
	}
	mmInput.defaultExpectation.results = &AsyncProducerMockInputResults{ch1}
	mmInput.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmInput.mock
}

// Set uses given function f to mock the AsyncProducer.Input method
func (mmInput *mAsyncProducerMockInput) Set(f func() (ch1 chan<- *mm_sarama.ProducerMessage)) *AsyncProducerMock {
	if mmInput.defaultExpectation != nil {
		mmInput.mock.t.Fatalf("Default expectation is already set for the AsyncProducer.Input method")
	}

	if len(mmInput.expectations) > 0 {
		mmInput.mock.t.Fatalf("Some expectations are already set for the AsyncProducer.Input method")
	}

	mmInput.mock.funcInput = f
	mmInput.mock.funcInputOrigin = minimock.CallerInfo(1)
	return mmInput.mock
}

// Times sets number of times AsyncProducer.Input should be invoked
func (mmInput *mAsyncProducerMockInput) Times(n uint64) *mAsyncProducerMockInput {
	if n == 0 {
		mmInput.mock.t.Fatalf("Times of AsyncProducerMock.Input mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmInput.expectedInvocations, n)
	mmInput.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmInput
}

func (mmInput *mAsyncProducerMockInput) invocationsDone() bool {
	if len(mmInput.expectations) == 0 && mmInput.defaultExpectation == nil && mmInput.mock.funcInput == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmInput.mock.afterInputCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmInput.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Input implements mm_sarama.AsyncProducer
func (mmInput *AsyncProducerMock) Input() (ch1 chan<- *mm_sarama.ProducerMessage) {
	mm_atomic.AddUint64(&mmInput.beforeInputCounter, 1)
	defer mm_atomic.AddUint64(&mmInput.afterInputCounter, 1)

	mmInput.t.Helper()

	if mmInput.inspectFuncInput != nil {
		mmInput.inspectFuncInput()
	}

	if mmInput.InputMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmInput.InputMock.defaultExpectation.Counter, 1)

		mm_results := mmInput.InputMock.defaultExpectation.results
		if mm_results == nil {
			mmInput.t.Fatal("No results are set for the AsyncProducerMock.Input")
		}
		return (*mm_results).ch1
	}
	if mmInput.funcInput != nil {
		return mmInput.funcInput()
	}
	mmInput.t.Fatalf("Unexpected call to AsyncProducerMock.Input.")
	return
}

// InputAfterCounter returns a count of finished AsyncProducerMock.Input invocations
func (mmInput *AsyncProducerMock) InputAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInput.afterInputCounter)
}

// InputBeforeCounter returns a count of AsyncProducerMock.Input invocations
func (mmInput *AsyncProducerMock) InputBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInput.beforeInputCounter)
}

// MinimockInputDone returns true if the count of the Input invocations corresponds
// the number of defined expectations
func (m *AsyncProducerMock) MinimockInputDone() bool {
	if m.InputMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.InputMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.InputMock.invocationsDone()
}

// MinimockInputInspect logs each unmet expectation
func (m *AsyncProducerMock) MinimockInputInspect() {
	for _, e := range m.InputMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to AsyncProducerMock.Input")
		}
	}

	afterInputCounter := mm_atomic.LoadUint64(&m.afterInputCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.InputMock.defaultExpectation != nil && afterInputCounter < 1 {
		m.t.Errorf("Expected call to AsyncProducerMock.Input at\n%s", m.InputMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInput != nil && afterInputCounter < 1 {
		m.t.Errorf("Expected call to AsyncProducerMock.Input at\n%s", m.funcInputOrigin)
	}

	if !m.InputMock.invocationsDone() && afterInputCounter > 0 {
		m.t.Errorf("Expected %d calls to AsyncProducerMock.Input at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.InputMock.expectedInvocations), m.InputMock.expectedInvocationsOrigin, afterInputCounter)
	}
}

type mAsyncProducerMockIsTransactional struct {
	optional           bool
	mock               *AsyncProducerMock
	defaultExpectation *AsyncProducerMockIsTransactionalExpectation
	expectations       []*AsyncProducerMockIsTransactionalExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AsyncProducerMockIsTransactionalExpectation specifies expectation struct of the AsyncProducer.IsTransactional
type AsyncProducerMockIsTransactionalExpectation struct {
	mock *AsyncProducerMock

	results      *AsyncProducerMockIsTransactionalResults
	returnOrigin string
	Counter      uint64
}

// AsyncProducerMockIsTransactionalResults contains results of the AsyncProducer.IsTransactional
type AsyncProducerMockIsTransactionalResults struct {
	b1 bool
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmIsTransactional *mAsyncProducerMockIsTransactional) Optional() *mAsyncProducerMockIsTransactional {
	mmIsTransactional.optional = true
	return mmIsTransactional
}

// Expect sets up expected params for AsyncProducer.IsTransactional
func (mmIsTransactional *mAsyncProducerMockIsTransactional) Expect() *mAsyncProducerMockIsTransactional {
	if mmIsTransactional.mock.funcIsTransactional != nil {
		mmIsTransactional.mock.t.Fatalf("AsyncProducerMock.IsTransactional mock is already set by Set")
	}

	if mmIsTransactional.defaultExpectation == nil {
		mmIsTransactional.defaultExpectation = &AsyncProducerMockIsTransactionalExpectation{}
	}

	return mmIsTransactional
}

// Inspect accepts an inspector function that has same arguments as the AsyncProducer.IsTransactional
func (mmIsTransactional *mAsyncProducerMockIsTransactional) Inspect(f func()) *mAsyncProducerMockIsTransactional {
	if mmIsTransactional.mock.inspectFuncIsTransactional != nil {
		mmIsTransactional.mock.t.Fatalf("Inspect function is already set for AsyncProducerMock.IsTransactional")
	}

	mmIsTransactional.mock.inspectFuncIsTransactional = f

	return mmIsTransactional
}

// Return sets up results that will be returned by AsyncProducer.IsTransactional
func (mmIsTransactional *mAsyncProducerMockIsTransactional) Return(b1 bool) *AsyncProducerMock {
	if mmIsTransactional.mock.funcIsTransactional != nil {
		mmIsTransactional.mock.t.Fatalf("AsyncProducerMock.IsTransactional mock is already set by Set")
	}

	if mmIsTransactional.defaultExpectation == nil {
		mmIsTransactional.defaultExpectation = &AsyncProducerMockIsTransactionalExpectation{mock: mmIsTransactional.mock}
	}
	mmIsTransactional.defaultExpectation.results = &AsyncProducerMockIsTransactionalResults{b1}
	mmIsTransactional.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmIsTransactional.mock
}

// Set uses given function f to mock the AsyncProducer.IsTransactional method
func (mmIsTransactional *mAsyncProducerMockIsTransactional) Set(f func() (b1 bool)) *AsyncProducerMock {
	if mmIsTransactional.defaultExpectation != nil {
		mmIsTransactional.mock.t.Fatalf("Default expectation is already set for the AsyncProducer.IsTransactional method")
	}

	if len(mmIsTransactional.expectations) > 0 {
		mmIsTransactional.mock.t.Fatalf("Some expectations are already set for the AsyncProducer.IsTransactional method")
	}

	mmIsTransactional.mock.funcIsTransactional = f
	mmIsTransactional.mock.funcIsTransactionalOrigin = minimock.CallerInfo(1)
	return mmIsTransactional.mock
}

// Times sets number of times AsyncProducer.IsTransactional should be invoked
func (mmIsTransactional *mAsyncProducerMockIsTransactional) Times(n uint64) *mAsyncProducerMockIsTransactional {
	if n == 0 {
		mmIsTransactional.mock.t.Fatalf("Times of AsyncProducerMock.IsTransactional mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmIsTransactional.expectedInvocations, n)
	mmIsTransactional.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmIsTransactional
}

func (mmIsTransactional *mAsyncProducerMockIsTransactional) invocationsDone() bool {
	if len(mmIsTransactional.expectations) == 0 && mmIsTransactional.defaultExpectation == nil && mmIsTransactional.mock.funcIsTransactional == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmIsTransactional.mock.afterIsTransactionalCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmIsTransactional.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// IsTransactional implements mm_sarama.AsyncProducer
func (mmIsTransactional *AsyncProducerMock) IsTransactional() (b1 bool) {
	mm_atomic.AddUint64(&mmIsTransactional.beforeIsTransactionalCounter, 1)
	defer mm_atomic.AddUint64(&mmIsTransactional.afterIsTransactionalCounter, 1)

	mmIsTransactional.t.Helper()

	if mmIsTransactional.inspectFuncIsTransactional != nil {
		mmIsTransactional.inspectFuncIsTransactional()
	}

	if mmIsTransactional.IsTransactionalMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIsTransactional.IsTransactionalMock.defaultExpectation.Counter, 1)

		mm_results := mmIsTransactional.IsTransactionalMock.defaultExpectation.results
		if mm_results == nil {
			mmIsTransactional.t.Fatal("No results are set for the AsyncProducerMock.IsTransactional")
		}
		return (*mm_results).b1
	}
	if mmIsTransactional.funcIsTransactional != nil {
		return mmIsTransactional.funcIsTransactional()
	}
	mmIsTransactional.t.Fatalf("Unexpected call to AsyncProducerMock.IsTransactional.")
	return
}

// IsTransactionalAfterCounter returns a count of finished AsyncProducerMock.IsTransactional invocations
func (mmIsTransactional *AsyncProducerMock) IsTransactionalAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsTransactional.afterIsTransactionalCounter)
}

// IsTransactionalBeforeCounter returns a count of AsyncProducerMock.IsTransactional invocations
func (mmIsTransactional *AsyncProducerMock) IsTransactionalBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsTransactional.beforeIsTransactionalCounter)
}

// MinimockIsTransactionalDone returns true if the count of the IsTransactional invocations corresponds
// the number of defined expectations
func (m *AsyncProducerMock) MinimockIsTransactionalDone() bool {
	if m.IsTransactionalMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.IsTransactionalMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.IsTransactionalMock.invocationsDone()
}

// MinimockIsTransactionalInspect logs each unmet expectation
func (m *AsyncProducerMock) MinimockIsTransactionalInspect() {
	for _, e := range m.IsTransactionalMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to AsyncProducerMock.IsTransactional")
		}
	}

	afterIsTransactionalCounter := mm_atomic.LoadUint64(&m.afterIsTransactionalCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.IsTransactionalMock.defaultExpectation != nil && afterIsTransactionalCounter < 1 {
		m.t.Errorf("Expected call to AsyncProducerMock.IsTransactional at\n%s", m.IsTransactionalMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsTransactional != nil && afterIsTransactionalCounter < 1 {
		m.t.Errorf("Expected call to AsyncProducerMock.IsTransactional at\n%s", m.funcIsTransactionalOrigin)
	}

	if !m.IsTransactionalMock.invocationsDone() && afterIsTransactionalCounter > 0 {
		m.t.Errorf("Expected %d calls to AsyncProducerMock.IsTransactional at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.IsTransactionalMock.expectedInvocations), m.IsTransactionalMock.expectedInvocationsOrigin, afterIsTransactionalCounter)
	}
}

type mAsyncProducerMockSuccesses struct {
	optional           bool
	mock               *AsyncProducerMock
	defaultExpectation *AsyncProducerMockSuccessesExpectation
	expectations       []*AsyncProducerMockSuccessesExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AsyncProducerMockSuccessesExpectation specifies expectation struct of the AsyncProducer.Successes
type AsyncProducerMockSuccessesExpectation struct {
	mock *AsyncProducerMock

	results      *AsyncProducerMockSuccessesResults
	returnOrigin string
	Counter      uint64
}

// AsyncProducerMockSuccessesResults contains results of the AsyncProducer.Successes
type AsyncProducerMockSuccessesResults struct {
	ch1 <-chan *mm_sarama.ProducerMessage
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSuccesses *mAsyncProducerMockSuccesses) Optional() *mAsyncProducerMockSuccesses {
	mmSuccesses.optional = true
	return mmSuccesses
}

// Expect sets up expected params for AsyncProducer.Successes
func (mmSuccesses *mAsyncProducerMockSuccesses) Expect() *mAsyncProducerMockSuccesses {
	if mmSuccesses.mock.funcSuccesses != nil {
		mmSuccesses.mock.t.Fatalf("AsyncProducerMock.Successes mock is already set by Set")
	}

	if mmSuccesses.defaultExpectation == nil {
		mmSuccesses.defaultExpectation = &AsyncProducerMockSuccessesExpectation{}
	}

	return mmSuccesses
}

// Inspect accepts an inspector function that has same arguments as the AsyncProducer.Successes
func (mmSuccesses *mAsyncProducerMockSuccesses) Inspect(f func()) *mAsyncProducerMockSuccesses {
	if mmSuccesses.mock.inspectFuncSuccesses != nil {
		mmSuccesses.mock.t.Fatalf("Inspect function is already set for AsyncProducerMock.Successes")
	}

	mmSuccesses.mock.inspectFuncSuccesses = f

	return mmSuccesses
}

// Return sets up results that will be returned by AsyncProducer.Successes
func (mmSuccesses *mAsyncProducerMockSuccesses) Return(ch1 <-chan *mm_sarama.ProducerMessage) *AsyncProducerMock {
	if mmSuccesses.mock.funcSuccesses != nil {
		mmSuccesses.mock.t.Fatalf("AsyncProducerMock.Successes mock is already set by Set")
	}

	if mmSuccesses.defaultExpectation == nil {
		mmSuccesses.defaultExpectation = &AsyncProducerMockSuccessesExpectation{mock: mmSuccesses.mock}
	}
	mmSuccesses.defaultExpectation.results = &AsyncProducerMockSuccessesResults{ch1}
	mmSuccesses.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSuccesses.mock
}

// Set uses given function f to mock the AsyncProducer.Successes method
func (mmSuccesses *mAsyncProducerMockSuccesses) Set(f func() (ch1 <-chan *mm_sarama.ProducerMessage)) *AsyncProducerMock {
	if mmSuccesses.defaultExpectation != nil {
		mmSuccesses.mock.t.Fatalf("Default expectation is already set for the AsyncProducer.Successes method")
	}

	if len(mmSuccesses.expectations) > 0 {
		mmSuccesses.mock.t.Fatalf("Some expectations are already set for the AsyncProducer.Successes method")
	}

	mmSuccesses.mock.funcSuccesses = f
	mmSuccesses.mock.funcSuccessesOrigin = minimock.CallerInfo(1)
	return mmSuccesses.mock
}

// Times sets number of times AsyncProducer.Successes should be invoked
func (mmSuccesses *mAsyncProducerMockSuccesses) Times(n uint64) *mAsyncProducerMockSuccesses {
	if n == 0 {
		mmSuccesses.mock.t.Fatalf("Times of AsyncProducerMock.Successes mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSuccesses.expectedInvocations, n)
	mmSuccesses.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSuccesses
}

func (mmSuccesses *mAsyncProducerMockSuccesses) invocationsDone() bool {
	if len(mmSuccesses.expectations) == 0 && mmSuccesses.defaultExpectation == nil && mmSuccesses.mock.funcSuccesses == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSuccesses.mock.afterSuccessesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSuccesses.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Successes implements mm_sarama.AsyncProducer
func (mmSuccesses *AsyncProducerMock) Successes() (ch1 <-chan *mm_sarama.ProducerMessage) {
	mm_atomic.AddUint64(&mmSuccesses.beforeSuccessesCounter, 1)
	defer mm_atomic.AddUint64(&mmSuccesses.afterSuccessesCounter, 1)

	mmSuccesses.t.Helper()

	if mmSuccesses.inspectFuncSuccesses != nil {
		mmSuccesses.inspectFuncSuccesses()
	}

	if mmSuccesses.SuccessesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSuccesses.SuccessesMock.defaultExpectation.Counter, 1)

		mm_results := mmSuccesses.SuccessesMock.defaultExpectation.results
		if mm_results == nil {
			mmSuccesses.t.Fatal("No results are set for the AsyncProducerMock.Successes")
		}
		return (*mm_results).ch1
	}
	if mmSuccesses.funcSuccesses != nil {
		return mmSuccesses.funcSuccesses()
	}
	mmSuccesses.t.Fatalf("Unexpected call to AsyncProducerMock.Successes.")
	return
}

// SuccessesAfterCounter returns a count of finished AsyncProducerMock.Successes invocations
func (mmSuccesses *AsyncProducerMock) SuccessesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSuccesses.afterSuccessesCounter)
}

// SuccessesBeforeCounter returns a count of AsyncProducerMock.Successes invocations
func (mmSuccesses *AsyncProducerMock) SuccessesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSuccesses.beforeSuccessesCounter)
}

// MinimockSuccessesDone returns true if the count of the Successes invocations corresponds
// the number of defined expectations
func (m *AsyncProducerMock) MinimockSuccessesDone() bool {
	if m.SuccessesMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SuccessesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SuccessesMock.invocationsDone()
}

// MinimockSuccessesInspect logs each unmet expectation
func (m *AsyncProducerMock) MinimockSuccessesInspect() {
	for _, e := range m.SuccessesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to AsyncProducerMock.Successes")
		}
	}

	afterSuccessesCounter := mm_atomic.LoadUint64(&m.afterSuccessesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SuccessesMock.defaultExpectation != nil && afterSuccessesCounter < 1 {
		m.t.Errorf("Expected call to AsyncProducerMock.Successes at\n%s", m.SuccessesMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSuccesses != nil && afterSuccessesCounter < 1 {
		m.t.Errorf("Expected call to AsyncProducerMock.Successes at\n%s", m.funcSuccessesOrigin)
	}

	if !m.SuccessesMock.invocationsDone() && afterSuccessesCounter > 0 {
		m.t.Errorf("Expected %d calls to AsyncProducerMock.Successes at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SuccessesMock.expectedInvocations), m.SuccessesMock.expectedInvocationsOrigin, afterSuccessesCounter)
	}
}

type mAsyncProducerMockTxnStatus struct {
	optional           bool
	mock               *AsyncProducerMock
	defaultExpectation *AsyncProducerMockTxnStatusExpectation
	expectations       []*AsyncProducerMockTxnStatusExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AsyncProducerMockTxnStatusExpectation specifies expectation struct of the AsyncProducer.TxnStatus
type AsyncProducerMockTxnStatusExpectation struct {
	mock *AsyncProducerMock

	results      *AsyncProducerMockTxnStatusResults
	returnOrigin string
	Counter      uint64
}

// AsyncProducerMockTxnStatusResults contains results of the AsyncProducer.TxnStatus
type AsyncProducerMockTxnStatusResults struct {
	p1 mm_sarama.ProducerTxnStatusFlag
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmTxnStatus *mAsyncProducerMockTxnStatus) Optional() *mAsyncProducerMockTxnStatus {
	mmTxnStatus.optional = true
	return mmTxnStatus
}

// Expect sets up expected params for AsyncProducer.TxnStatus
func (mmTxnStatus *mAsyncProducerMockTxnStatus) Expect() *mAsyncProducerMockTxnStatus {
	if mmTxnStatus.mock.funcTxnStatus != nil {
		mmTxnStatus.mock.t.Fatalf("AsyncProducerMock.TxnStatus mock is already set by Set")
	}

	if mmTxnStatus.defaultExpectation == nil {
		mmTxnStatus.defaultExpectation = &AsyncProducerMockTxnStatusExpectation{}
	}

	return mmTxnStatus
}

// Inspect accepts an inspector function that has same arguments as the AsyncProducer.TxnStatus
func (mmTxnStatus *mAsyncProducerMockTxnStatus) Inspect(f func()) *mAsyncProducerMockTxnStatus {
	if mmTxnStatus.mock.inspectFuncTxnStatus != nil {
		mmTxnStatus.mock.t.Fatalf("Inspect function is already set for AsyncProducerMock.TxnStatus")
	}

	mmTxnStatus.mock.inspectFuncTxnStatus = f

	return mmTxnStatus
}

// Return sets up results that will be returned by AsyncProducer.TxnStatus
func (mmTxnStatus *mAsyncProducerMockTxnStatus) Return(p1 mm_sarama.ProducerTxnStatusFlag) *AsyncProducerMock {
	if mmTxnStatus.mock.funcTxnStatus != nil {
		mmTxnStatus.mock.t.Fatalf("AsyncProducerMock.TxnStatus mock is already set by Set")
	}

	if mmTxnStatus.defaultExpectation == nil {
		mmTxnStatus.defaultExpectation = &AsyncProducerMockTxnStatusExpectation{mock: mmTxnStatus.mock}
	}
	mmTxnStatus.defaultExpectation.results = &AsyncProducerMockTxnStatusResults{p1}
	mmTxnStatus.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmTxnStatus.mock
}

// Set uses given function f to mock the AsyncProducer.TxnStatus method
func (mmTxnStatus *mAsyncProducerMockTxnStatus) Set(f func() (p1 mm_sarama.ProducerTxnStatusFlag)) *AsyncProducerMock {
	if mmTxnStatus.defaultExpectation != nil {
		mmTxnStatus.mock.t.Fatalf("Default expectation is already set for the AsyncProducer.TxnStatus method")
	}

	if len(mmTxnStatus.expectations) > 0 {
		mmTxnStatus.mock.t.Fatalf("Some expectations are already set for the AsyncProducer.TxnStatus method")
	}

	mmTxnStatus.mock.funcTxnStatus = f
	mmTxnStatus.mock.funcTxnStatusOrigin = minimock.CallerInfo(1)
	return mmTxnStatus.mock
}

// Times sets number of times AsyncProducer.TxnStatus should be invoked
func (mmTxnStatus *mAsyncProducerMockTxnStatus) Times(n uint64) *mAsyncProducerMockTxnStatus {
	if n == 0 {
		mmTxnStatus.mock.t.Fatalf("Times of AsyncProducerMock.TxnStatus mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmTxnStatus.expectedInvocations, n)
	mmTxnStatus.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmTxnStatus
}

func (mmTxnStatus *mAsyncProducerMockTxnStatus) invocationsDone() bool {
	if len(mmTxnStatus.expectations) == 0 && mmTxnStatus.defaultExpectation == nil && mmTxnStatus.mock.funcTxnStatus == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmTxnStatus.mock.afterTxnStatusCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmTxnStatus.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// TxnStatus implements mm_sarama.AsyncProducer
func (mmTxnStatus *AsyncProducerMock) TxnStatus() (p1 mm_sarama.ProducerTxnStatusFlag) {
	mm_atomic.AddUint64(&mmTxnStatus.beforeTxnStatusCounter, 1)
	defer mm_atomic.AddUint64(&mmTxnStatus.afterTxnStatusCounter, 1)

	mmTxnStatus.t.Helper()

	if mmTxnStatus.inspectFuncTxnStatus != nil {
		mmTxnStatus.inspectFuncTxnStatus()
	}

	if mmTxnStatus.TxnStatusMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTxnStatus.TxnStatusMock.defaultExpectation.Counter, 1)

		mm_results := mmTxnStatus.TxnStatusMock.defaultExpectation.results
		if mm_results == nil {
			mmTxnStatus.t.Fatal("No results are set for the AsyncProducerMock.TxnStatus")
		}
		return (*mm_results).p1
	}
	if mmTxnStatus.funcTxnStatus != nil {
		return mmTxnStatus.funcTxnStatus()
	}
	mmTxnStatus.t.Fatalf("Unexpected call to AsyncProducerMock.TxnStatus.")
	return
}

// TxnStatusAfterCounter returns a count of finished AsyncProducerMock.TxnStatus invocations
func (mmTxnStatus *AsyncProducerMock) TxnStatusAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTxnStatus.afterTxnStatusCounter)
}

// TxnStatusBeforeCounter returns a count of AsyncProducerMock.TxnStatus invocations
func (mmTxnStatus *AsyncProducerMock) TxnStatusBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTxnStatus.beforeTxnStatusCounter)
}

// MinimockTxnStatusDone returns true if the count of the TxnStatus invocations corresponds
// the number of defined expectations
func (m *AsyncProducerMock) MinimockTxnStatusDone() bool {
	if m.TxnStatusMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.TxnStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.TxnStatusMock.invocationsDone()
}

// MinimockTxnStatusInspect logs each unmet expectation
func (m *AsyncProducerMock) MinimockTxnStatusInspect() {
	for _, e := range m.TxnStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to AsyncProducerMock.TxnStatus")
		}
	}

	afterTxnStatusCounter := mm_atomic.LoadUint64(&m.afterTxnStatusCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.TxnStatusMock.defaultExpectation != nil && afterTxnStatusCounter < 1 {
		m.t.Errorf("Expected call to AsyncProducerMock.TxnStatus at\n%s", m.TxnStatusMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTxnStatus != nil && afterTxnStatusCounter < 1 {
		m.t.Errorf("Expected call to AsyncProducerMock.TxnStatus at\n%s", m.funcTxnStatusOrigin)
	}

	if !m.TxnStatusMock.invocationsDone() && afterTxnStatusCounter > 0 {
		m.t.Errorf("Expected %d calls to AsyncProducerMock.TxnStatus at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.TxnStatusMock.expectedInvocations), m.TxnStatusMock.expectedInvocationsOrigin, afterTxnStatusCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *AsyncProducerMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAbortTxnInspect()

			m.MinimockAddMessageToTxnInspect()

			m.MinimockAddOffsetsToTxnInspect()

			m.MinimockAsyncCloseInspect()

			m.MinimockBeginTxnInspect()

			m.MinimockCloseInspect()

			m.MinimockCommitTxnInspect()

			m.MinimockErrorsInspect()

			m.MinimockInputInspect()

			m.MinimockIsTransactionalInspect()

			m.MinimockSuccessesInspect()

			m.MinimockTxnStatusInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *AsyncProducerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *AsyncProducerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAbortTxnDone() &&
		m.MinimockAddMessageToTxnDone() &&
		m.MinimockAddOffsetsToTxnDone() &&
		m.MinimockAsyncCloseDone() &&
		m.MinimockBeginTxnDone() &&
		m.MinimockCloseDone() &&
		m.MinimockCommitTxnDone() &&
		m.MinimockErrorsDone() &&
		m.MinimockInputDone() &&
		m.MinimockIsTransactionalDone() &&
		m.MinimockSuccessesDone() &&
		m.MinimockTxnStatusDone()
}
