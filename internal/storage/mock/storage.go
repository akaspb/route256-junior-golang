// Code generated by http://github.com/gojuno/minimock (v3.4.0). DO NOT EDIT.

package mock

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"gitlab.ozon.dev/siralexpeter/Homework/internal/models"
)

// StorageMock implements mm_storage.Storage
type StorageMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcGetOrder          func(orderId models.IDType) (o1 models.Order, err error)
	funcGetOrderOrigin    string
	inspectFuncGetOrder   func(orderId models.IDType)
	afterGetOrderCounter  uint64
	beforeGetOrderCounter uint64
	GetOrderMock          mStorageMockGetOrder

	funcGetOrderIDs          func() (ia1 []models.IDType, err error)
	funcGetOrderIDsOrigin    string
	inspectFuncGetOrderIDs   func()
	afterGetOrderIDsCounter  uint64
	beforeGetOrderIDsCounter uint64
	GetOrderIDsMock          mStorageMockGetOrderIDs

	funcGetReturnIDs          func() (ia1 []models.IDType, err error)
	funcGetReturnIDsOrigin    string
	inspectFuncGetReturnIDs   func()
	afterGetReturnIDsCounter  uint64
	beforeGetReturnIDsCounter uint64
	GetReturnIDsMock          mStorageMockGetReturnIDs

	funcRemoveOrder          func(orderId models.IDType) (err error)
	funcRemoveOrderOrigin    string
	inspectFuncRemoveOrder   func(orderId models.IDType)
	afterRemoveOrderCounter  uint64
	beforeRemoveOrderCounter uint64
	RemoveOrderMock          mStorageMockRemoveOrder

	funcSetOrder          func(order models.Order) (err error)
	funcSetOrderOrigin    string
	inspectFuncSetOrder   func(order models.Order)
	afterSetOrderCounter  uint64
	beforeSetOrderCounter uint64
	SetOrderMock          mStorageMockSetOrder
}

// NewStorageMock returns a mock for mm_storage.Storage
func NewStorageMock(t minimock.Tester) *StorageMock {
	m := &StorageMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetOrderMock = mStorageMockGetOrder{mock: m}
	m.GetOrderMock.callArgs = []*StorageMockGetOrderParams{}

	m.GetOrderIDsMock = mStorageMockGetOrderIDs{mock: m}

	m.GetReturnIDsMock = mStorageMockGetReturnIDs{mock: m}

	m.RemoveOrderMock = mStorageMockRemoveOrder{mock: m}
	m.RemoveOrderMock.callArgs = []*StorageMockRemoveOrderParams{}

	m.SetOrderMock = mStorageMockSetOrder{mock: m}
	m.SetOrderMock.callArgs = []*StorageMockSetOrderParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mStorageMockGetOrder struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockGetOrderExpectation
	expectations       []*StorageMockGetOrderExpectation

	callArgs []*StorageMockGetOrderParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockGetOrderExpectation specifies expectation struct of the Storage.GetOrder
type StorageMockGetOrderExpectation struct {
	mock               *StorageMock
	params             *StorageMockGetOrderParams
	paramPtrs          *StorageMockGetOrderParamPtrs
	expectationOrigins StorageMockGetOrderExpectationOrigins
	results            *StorageMockGetOrderResults
	returnOrigin       string
	Counter            uint64
}

// StorageMockGetOrderParams contains parameters of the Storage.GetOrder
type StorageMockGetOrderParams struct {
	orderId models.IDType
}

// StorageMockGetOrderParamPtrs contains pointers to parameters of the Storage.GetOrder
type StorageMockGetOrderParamPtrs struct {
	orderId *models.IDType
}

// StorageMockGetOrderResults contains results of the Storage.GetOrder
type StorageMockGetOrderResults struct {
	o1  models.Order
	err error
}

// StorageMockGetOrderOrigins contains origins of expectations of the Storage.GetOrder
type StorageMockGetOrderExpectationOrigins struct {
	origin        string
	originOrderId string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetOrder *mStorageMockGetOrder) Optional() *mStorageMockGetOrder {
	mmGetOrder.optional = true
	return mmGetOrder
}

// Expect sets up expected params for Storage.GetOrder
func (mmGetOrder *mStorageMockGetOrder) Expect(orderId models.IDType) *mStorageMockGetOrder {
	if mmGetOrder.mock.funcGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("StorageMock.GetOrder mock is already set by Set")
	}

	if mmGetOrder.defaultExpectation == nil {
		mmGetOrder.defaultExpectation = &StorageMockGetOrderExpectation{}
	}

	if mmGetOrder.defaultExpectation.paramPtrs != nil {
		mmGetOrder.mock.t.Fatalf("StorageMock.GetOrder mock is already set by ExpectParams functions")
	}

	mmGetOrder.defaultExpectation.params = &StorageMockGetOrderParams{orderId}
	mmGetOrder.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetOrder.expectations {
		if minimock.Equal(e.params, mmGetOrder.defaultExpectation.params) {
			mmGetOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetOrder.defaultExpectation.params)
		}
	}

	return mmGetOrder
}

// ExpectOrderIdParam1 sets up expected param orderId for Storage.GetOrder
func (mmGetOrder *mStorageMockGetOrder) ExpectOrderIdParam1(orderId models.IDType) *mStorageMockGetOrder {
	if mmGetOrder.mock.funcGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("StorageMock.GetOrder mock is already set by Set")
	}

	if mmGetOrder.defaultExpectation == nil {
		mmGetOrder.defaultExpectation = &StorageMockGetOrderExpectation{}
	}

	if mmGetOrder.defaultExpectation.params != nil {
		mmGetOrder.mock.t.Fatalf("StorageMock.GetOrder mock is already set by Expect")
	}

	if mmGetOrder.defaultExpectation.paramPtrs == nil {
		mmGetOrder.defaultExpectation.paramPtrs = &StorageMockGetOrderParamPtrs{}
	}
	mmGetOrder.defaultExpectation.paramPtrs.orderId = &orderId
	mmGetOrder.defaultExpectation.expectationOrigins.originOrderId = minimock.CallerInfo(1)

	return mmGetOrder
}

// Inspect accepts an inspector function that has same arguments as the Storage.GetOrder
func (mmGetOrder *mStorageMockGetOrder) Inspect(f func(orderId models.IDType)) *mStorageMockGetOrder {
	if mmGetOrder.mock.inspectFuncGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("Inspect function is already set for StorageMock.GetOrder")
	}

	mmGetOrder.mock.inspectFuncGetOrder = f

	return mmGetOrder
}

// Return sets up results that will be returned by Storage.GetOrder
func (mmGetOrder *mStorageMockGetOrder) Return(o1 models.Order, err error) *StorageMock {
	if mmGetOrder.mock.funcGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("StorageMock.GetOrder mock is already set by Set")
	}

	if mmGetOrder.defaultExpectation == nil {
		mmGetOrder.defaultExpectation = &StorageMockGetOrderExpectation{mock: mmGetOrder.mock}
	}
	mmGetOrder.defaultExpectation.results = &StorageMockGetOrderResults{o1, err}
	mmGetOrder.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetOrder.mock
}

// Set uses given function f to mock the Storage.GetOrder method
func (mmGetOrder *mStorageMockGetOrder) Set(f func(orderId models.IDType) (o1 models.Order, err error)) *StorageMock {
	if mmGetOrder.defaultExpectation != nil {
		mmGetOrder.mock.t.Fatalf("Default expectation is already set for the Storage.GetOrder method")
	}

	if len(mmGetOrder.expectations) > 0 {
		mmGetOrder.mock.t.Fatalf("Some expectations are already set for the Storage.GetOrder method")
	}

	mmGetOrder.mock.funcGetOrder = f
	mmGetOrder.mock.funcGetOrderOrigin = minimock.CallerInfo(1)
	return mmGetOrder.mock
}

// When sets expectation for the Storage.GetOrder which will trigger the result defined by the following
// Then helper
func (mmGetOrder *mStorageMockGetOrder) When(orderId models.IDType) *StorageMockGetOrderExpectation {
	if mmGetOrder.mock.funcGetOrder != nil {
		mmGetOrder.mock.t.Fatalf("StorageMock.GetOrder mock is already set by Set")
	}

	expectation := &StorageMockGetOrderExpectation{
		mock:               mmGetOrder.mock,
		params:             &StorageMockGetOrderParams{orderId},
		expectationOrigins: StorageMockGetOrderExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetOrder.expectations = append(mmGetOrder.expectations, expectation)
	return expectation
}

// Then sets up Storage.GetOrder return parameters for the expectation previously defined by the When method
func (e *StorageMockGetOrderExpectation) Then(o1 models.Order, err error) *StorageMock {
	e.results = &StorageMockGetOrderResults{o1, err}
	return e.mock
}

// Times sets number of times Storage.GetOrder should be invoked
func (mmGetOrder *mStorageMockGetOrder) Times(n uint64) *mStorageMockGetOrder {
	if n == 0 {
		mmGetOrder.mock.t.Fatalf("Times of StorageMock.GetOrder mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetOrder.expectedInvocations, n)
	mmGetOrder.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetOrder
}

func (mmGetOrder *mStorageMockGetOrder) invocationsDone() bool {
	if len(mmGetOrder.expectations) == 0 && mmGetOrder.defaultExpectation == nil && mmGetOrder.mock.funcGetOrder == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetOrder.mock.afterGetOrderCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetOrder.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetOrder implements mm_storage.Storage
func (mmGetOrder *StorageMock) GetOrder(orderId models.IDType) (o1 models.Order, err error) {
	mm_atomic.AddUint64(&mmGetOrder.beforeGetOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmGetOrder.afterGetOrderCounter, 1)

	mmGetOrder.t.Helper()

	if mmGetOrder.inspectFuncGetOrder != nil {
		mmGetOrder.inspectFuncGetOrder(orderId)
	}

	mm_params := StorageMockGetOrderParams{orderId}

	// Record call args
	mmGetOrder.GetOrderMock.mutex.Lock()
	mmGetOrder.GetOrderMock.callArgs = append(mmGetOrder.GetOrderMock.callArgs, &mm_params)
	mmGetOrder.GetOrderMock.mutex.Unlock()

	for _, e := range mmGetOrder.GetOrderMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.o1, e.results.err
		}
	}

	if mmGetOrder.GetOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetOrder.GetOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmGetOrder.GetOrderMock.defaultExpectation.params
		mm_want_ptrs := mmGetOrder.GetOrderMock.defaultExpectation.paramPtrs

		mm_got := StorageMockGetOrderParams{orderId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.orderId != nil && !minimock.Equal(*mm_want_ptrs.orderId, mm_got.orderId) {
				mmGetOrder.t.Errorf("StorageMock.GetOrder got unexpected parameter orderId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetOrder.GetOrderMock.defaultExpectation.expectationOrigins.originOrderId, *mm_want_ptrs.orderId, mm_got.orderId, minimock.Diff(*mm_want_ptrs.orderId, mm_got.orderId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetOrder.t.Errorf("StorageMock.GetOrder got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetOrder.GetOrderMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetOrder.GetOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmGetOrder.t.Fatal("No results are set for the StorageMock.GetOrder")
		}
		return (*mm_results).o1, (*mm_results).err
	}
	if mmGetOrder.funcGetOrder != nil {
		return mmGetOrder.funcGetOrder(orderId)
	}
	mmGetOrder.t.Fatalf("Unexpected call to StorageMock.GetOrder. %v", orderId)
	return
}

// GetOrderAfterCounter returns a count of finished StorageMock.GetOrder invocations
func (mmGetOrder *StorageMock) GetOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrder.afterGetOrderCounter)
}

// GetOrderBeforeCounter returns a count of StorageMock.GetOrder invocations
func (mmGetOrder *StorageMock) GetOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrder.beforeGetOrderCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.GetOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetOrder *mStorageMockGetOrder) Calls() []*StorageMockGetOrderParams {
	mmGetOrder.mutex.RLock()

	argCopy := make([]*StorageMockGetOrderParams, len(mmGetOrder.callArgs))
	copy(argCopy, mmGetOrder.callArgs)

	mmGetOrder.mutex.RUnlock()

	return argCopy
}

// MinimockGetOrderDone returns true if the count of the GetOrder invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockGetOrderDone() bool {
	if m.GetOrderMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetOrderMock.invocationsDone()
}

// MinimockGetOrderInspect logs each unmet expectation
func (m *StorageMock) MinimockGetOrderInspect() {
	for _, e := range m.GetOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.GetOrder at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetOrderCounter := mm_atomic.LoadUint64(&m.afterGetOrderCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetOrderMock.defaultExpectation != nil && afterGetOrderCounter < 1 {
		if m.GetOrderMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.GetOrder at\n%s", m.GetOrderMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.GetOrder at\n%s with params: %#v", m.GetOrderMock.defaultExpectation.expectationOrigins.origin, *m.GetOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOrder != nil && afterGetOrderCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.GetOrder at\n%s", m.funcGetOrderOrigin)
	}

	if !m.GetOrderMock.invocationsDone() && afterGetOrderCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.GetOrder at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetOrderMock.expectedInvocations), m.GetOrderMock.expectedInvocationsOrigin, afterGetOrderCounter)
	}
}

type mStorageMockGetOrderIDs struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockGetOrderIDsExpectation
	expectations       []*StorageMockGetOrderIDsExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockGetOrderIDsExpectation specifies expectation struct of the Storage.GetOrderIDs
type StorageMockGetOrderIDsExpectation struct {
	mock *StorageMock

	results      *StorageMockGetOrderIDsResults
	returnOrigin string
	Counter      uint64
}

// StorageMockGetOrderIDsResults contains results of the Storage.GetOrderIDs
type StorageMockGetOrderIDsResults struct {
	ia1 []models.IDType
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetOrderIDs *mStorageMockGetOrderIDs) Optional() *mStorageMockGetOrderIDs {
	mmGetOrderIDs.optional = true
	return mmGetOrderIDs
}

// Expect sets up expected params for Storage.GetOrderIDs
func (mmGetOrderIDs *mStorageMockGetOrderIDs) Expect() *mStorageMockGetOrderIDs {
	if mmGetOrderIDs.mock.funcGetOrderIDs != nil {
		mmGetOrderIDs.mock.t.Fatalf("StorageMock.GetOrderIDs mock is already set by Set")
	}

	if mmGetOrderIDs.defaultExpectation == nil {
		mmGetOrderIDs.defaultExpectation = &StorageMockGetOrderIDsExpectation{}
	}

	return mmGetOrderIDs
}

// Inspect accepts an inspector function that has same arguments as the Storage.GetOrderIDs
func (mmGetOrderIDs *mStorageMockGetOrderIDs) Inspect(f func()) *mStorageMockGetOrderIDs {
	if mmGetOrderIDs.mock.inspectFuncGetOrderIDs != nil {
		mmGetOrderIDs.mock.t.Fatalf("Inspect function is already set for StorageMock.GetOrderIDs")
	}

	mmGetOrderIDs.mock.inspectFuncGetOrderIDs = f

	return mmGetOrderIDs
}

// Return sets up results that will be returned by Storage.GetOrderIDs
func (mmGetOrderIDs *mStorageMockGetOrderIDs) Return(ia1 []models.IDType, err error) *StorageMock {
	if mmGetOrderIDs.mock.funcGetOrderIDs != nil {
		mmGetOrderIDs.mock.t.Fatalf("StorageMock.GetOrderIDs mock is already set by Set")
	}

	if mmGetOrderIDs.defaultExpectation == nil {
		mmGetOrderIDs.defaultExpectation = &StorageMockGetOrderIDsExpectation{mock: mmGetOrderIDs.mock}
	}
	mmGetOrderIDs.defaultExpectation.results = &StorageMockGetOrderIDsResults{ia1, err}
	mmGetOrderIDs.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetOrderIDs.mock
}

// Set uses given function f to mock the Storage.GetOrderIDs method
func (mmGetOrderIDs *mStorageMockGetOrderIDs) Set(f func() (ia1 []models.IDType, err error)) *StorageMock {
	if mmGetOrderIDs.defaultExpectation != nil {
		mmGetOrderIDs.mock.t.Fatalf("Default expectation is already set for the Storage.GetOrderIDs method")
	}

	if len(mmGetOrderIDs.expectations) > 0 {
		mmGetOrderIDs.mock.t.Fatalf("Some expectations are already set for the Storage.GetOrderIDs method")
	}

	mmGetOrderIDs.mock.funcGetOrderIDs = f
	mmGetOrderIDs.mock.funcGetOrderIDsOrigin = minimock.CallerInfo(1)
	return mmGetOrderIDs.mock
}

// Times sets number of times Storage.GetOrderIDs should be invoked
func (mmGetOrderIDs *mStorageMockGetOrderIDs) Times(n uint64) *mStorageMockGetOrderIDs {
	if n == 0 {
		mmGetOrderIDs.mock.t.Fatalf("Times of StorageMock.GetOrderIDs mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetOrderIDs.expectedInvocations, n)
	mmGetOrderIDs.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetOrderIDs
}

func (mmGetOrderIDs *mStorageMockGetOrderIDs) invocationsDone() bool {
	if len(mmGetOrderIDs.expectations) == 0 && mmGetOrderIDs.defaultExpectation == nil && mmGetOrderIDs.mock.funcGetOrderIDs == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetOrderIDs.mock.afterGetOrderIDsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetOrderIDs.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetOrderIDs implements mm_storage.Storage
func (mmGetOrderIDs *StorageMock) GetOrderIDs() (ia1 []models.IDType, err error) {
	mm_atomic.AddUint64(&mmGetOrderIDs.beforeGetOrderIDsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetOrderIDs.afterGetOrderIDsCounter, 1)

	mmGetOrderIDs.t.Helper()

	if mmGetOrderIDs.inspectFuncGetOrderIDs != nil {
		mmGetOrderIDs.inspectFuncGetOrderIDs()
	}

	if mmGetOrderIDs.GetOrderIDsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetOrderIDs.GetOrderIDsMock.defaultExpectation.Counter, 1)

		mm_results := mmGetOrderIDs.GetOrderIDsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetOrderIDs.t.Fatal("No results are set for the StorageMock.GetOrderIDs")
		}
		return (*mm_results).ia1, (*mm_results).err
	}
	if mmGetOrderIDs.funcGetOrderIDs != nil {
		return mmGetOrderIDs.funcGetOrderIDs()
	}
	mmGetOrderIDs.t.Fatalf("Unexpected call to StorageMock.GetOrderIDs.")
	return
}

// GetOrderIDsAfterCounter returns a count of finished StorageMock.GetOrderIDs invocations
func (mmGetOrderIDs *StorageMock) GetOrderIDsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrderIDs.afterGetOrderIDsCounter)
}

// GetOrderIDsBeforeCounter returns a count of StorageMock.GetOrderIDs invocations
func (mmGetOrderIDs *StorageMock) GetOrderIDsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrderIDs.beforeGetOrderIDsCounter)
}

// MinimockGetOrderIDsDone returns true if the count of the GetOrderIDs invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockGetOrderIDsDone() bool {
	if m.GetOrderIDsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetOrderIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetOrderIDsMock.invocationsDone()
}

// MinimockGetOrderIDsInspect logs each unmet expectation
func (m *StorageMock) MinimockGetOrderIDsInspect() {
	for _, e := range m.GetOrderIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to StorageMock.GetOrderIDs")
		}
	}

	afterGetOrderIDsCounter := mm_atomic.LoadUint64(&m.afterGetOrderIDsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetOrderIDsMock.defaultExpectation != nil && afterGetOrderIDsCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.GetOrderIDs at\n%s", m.GetOrderIDsMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOrderIDs != nil && afterGetOrderIDsCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.GetOrderIDs at\n%s", m.funcGetOrderIDsOrigin)
	}

	if !m.GetOrderIDsMock.invocationsDone() && afterGetOrderIDsCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.GetOrderIDs at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetOrderIDsMock.expectedInvocations), m.GetOrderIDsMock.expectedInvocationsOrigin, afterGetOrderIDsCounter)
	}
}

type mStorageMockGetReturnIDs struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockGetReturnIDsExpectation
	expectations       []*StorageMockGetReturnIDsExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockGetReturnIDsExpectation specifies expectation struct of the Storage.GetReturnIDs
type StorageMockGetReturnIDsExpectation struct {
	mock *StorageMock

	results      *StorageMockGetReturnIDsResults
	returnOrigin string
	Counter      uint64
}

// StorageMockGetReturnIDsResults contains results of the Storage.GetReturnIDs
type StorageMockGetReturnIDsResults struct {
	ia1 []models.IDType
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetReturnIDs *mStorageMockGetReturnIDs) Optional() *mStorageMockGetReturnIDs {
	mmGetReturnIDs.optional = true
	return mmGetReturnIDs
}

// Expect sets up expected params for Storage.GetReturnIDs
func (mmGetReturnIDs *mStorageMockGetReturnIDs) Expect() *mStorageMockGetReturnIDs {
	if mmGetReturnIDs.mock.funcGetReturnIDs != nil {
		mmGetReturnIDs.mock.t.Fatalf("StorageMock.GetReturnIDs mock is already set by Set")
	}

	if mmGetReturnIDs.defaultExpectation == nil {
		mmGetReturnIDs.defaultExpectation = &StorageMockGetReturnIDsExpectation{}
	}

	return mmGetReturnIDs
}

// Inspect accepts an inspector function that has same arguments as the Storage.GetReturnIDs
func (mmGetReturnIDs *mStorageMockGetReturnIDs) Inspect(f func()) *mStorageMockGetReturnIDs {
	if mmGetReturnIDs.mock.inspectFuncGetReturnIDs != nil {
		mmGetReturnIDs.mock.t.Fatalf("Inspect function is already set for StorageMock.GetReturnIDs")
	}

	mmGetReturnIDs.mock.inspectFuncGetReturnIDs = f

	return mmGetReturnIDs
}

// Return sets up results that will be returned by Storage.GetReturnIDs
func (mmGetReturnIDs *mStorageMockGetReturnIDs) Return(ia1 []models.IDType, err error) *StorageMock {
	if mmGetReturnIDs.mock.funcGetReturnIDs != nil {
		mmGetReturnIDs.mock.t.Fatalf("StorageMock.GetReturnIDs mock is already set by Set")
	}

	if mmGetReturnIDs.defaultExpectation == nil {
		mmGetReturnIDs.defaultExpectation = &StorageMockGetReturnIDsExpectation{mock: mmGetReturnIDs.mock}
	}
	mmGetReturnIDs.defaultExpectation.results = &StorageMockGetReturnIDsResults{ia1, err}
	mmGetReturnIDs.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetReturnIDs.mock
}

// Set uses given function f to mock the Storage.GetReturnIDs method
func (mmGetReturnIDs *mStorageMockGetReturnIDs) Set(f func() (ia1 []models.IDType, err error)) *StorageMock {
	if mmGetReturnIDs.defaultExpectation != nil {
		mmGetReturnIDs.mock.t.Fatalf("Default expectation is already set for the Storage.GetReturnIDs method")
	}

	if len(mmGetReturnIDs.expectations) > 0 {
		mmGetReturnIDs.mock.t.Fatalf("Some expectations are already set for the Storage.GetReturnIDs method")
	}

	mmGetReturnIDs.mock.funcGetReturnIDs = f
	mmGetReturnIDs.mock.funcGetReturnIDsOrigin = minimock.CallerInfo(1)
	return mmGetReturnIDs.mock
}

// Times sets number of times Storage.GetReturnIDs should be invoked
func (mmGetReturnIDs *mStorageMockGetReturnIDs) Times(n uint64) *mStorageMockGetReturnIDs {
	if n == 0 {
		mmGetReturnIDs.mock.t.Fatalf("Times of StorageMock.GetReturnIDs mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetReturnIDs.expectedInvocations, n)
	mmGetReturnIDs.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetReturnIDs
}

func (mmGetReturnIDs *mStorageMockGetReturnIDs) invocationsDone() bool {
	if len(mmGetReturnIDs.expectations) == 0 && mmGetReturnIDs.defaultExpectation == nil && mmGetReturnIDs.mock.funcGetReturnIDs == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetReturnIDs.mock.afterGetReturnIDsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetReturnIDs.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetReturnIDs implements mm_storage.Storage
func (mmGetReturnIDs *StorageMock) GetReturnIDs() (ia1 []models.IDType, err error) {
	mm_atomic.AddUint64(&mmGetReturnIDs.beforeGetReturnIDsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetReturnIDs.afterGetReturnIDsCounter, 1)

	mmGetReturnIDs.t.Helper()

	if mmGetReturnIDs.inspectFuncGetReturnIDs != nil {
		mmGetReturnIDs.inspectFuncGetReturnIDs()
	}

	if mmGetReturnIDs.GetReturnIDsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetReturnIDs.GetReturnIDsMock.defaultExpectation.Counter, 1)

		mm_results := mmGetReturnIDs.GetReturnIDsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetReturnIDs.t.Fatal("No results are set for the StorageMock.GetReturnIDs")
		}
		return (*mm_results).ia1, (*mm_results).err
	}
	if mmGetReturnIDs.funcGetReturnIDs != nil {
		return mmGetReturnIDs.funcGetReturnIDs()
	}
	mmGetReturnIDs.t.Fatalf("Unexpected call to StorageMock.GetReturnIDs.")
	return
}

// GetReturnIDsAfterCounter returns a count of finished StorageMock.GetReturnIDs invocations
func (mmGetReturnIDs *StorageMock) GetReturnIDsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetReturnIDs.afterGetReturnIDsCounter)
}

// GetReturnIDsBeforeCounter returns a count of StorageMock.GetReturnIDs invocations
func (mmGetReturnIDs *StorageMock) GetReturnIDsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetReturnIDs.beforeGetReturnIDsCounter)
}

// MinimockGetReturnIDsDone returns true if the count of the GetReturnIDs invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockGetReturnIDsDone() bool {
	if m.GetReturnIDsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetReturnIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetReturnIDsMock.invocationsDone()
}

// MinimockGetReturnIDsInspect logs each unmet expectation
func (m *StorageMock) MinimockGetReturnIDsInspect() {
	for _, e := range m.GetReturnIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to StorageMock.GetReturnIDs")
		}
	}

	afterGetReturnIDsCounter := mm_atomic.LoadUint64(&m.afterGetReturnIDsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetReturnIDsMock.defaultExpectation != nil && afterGetReturnIDsCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.GetReturnIDs at\n%s", m.GetReturnIDsMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetReturnIDs != nil && afterGetReturnIDsCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.GetReturnIDs at\n%s", m.funcGetReturnIDsOrigin)
	}

	if !m.GetReturnIDsMock.invocationsDone() && afterGetReturnIDsCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.GetReturnIDs at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetReturnIDsMock.expectedInvocations), m.GetReturnIDsMock.expectedInvocationsOrigin, afterGetReturnIDsCounter)
	}
}

type mStorageMockRemoveOrder struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockRemoveOrderExpectation
	expectations       []*StorageMockRemoveOrderExpectation

	callArgs []*StorageMockRemoveOrderParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockRemoveOrderExpectation specifies expectation struct of the Storage.RemoveOrder
type StorageMockRemoveOrderExpectation struct {
	mock               *StorageMock
	params             *StorageMockRemoveOrderParams
	paramPtrs          *StorageMockRemoveOrderParamPtrs
	expectationOrigins StorageMockRemoveOrderExpectationOrigins
	results            *StorageMockRemoveOrderResults
	returnOrigin       string
	Counter            uint64
}

// StorageMockRemoveOrderParams contains parameters of the Storage.RemoveOrder
type StorageMockRemoveOrderParams struct {
	orderId models.IDType
}

// StorageMockRemoveOrderParamPtrs contains pointers to parameters of the Storage.RemoveOrder
type StorageMockRemoveOrderParamPtrs struct {
	orderId *models.IDType
}

// StorageMockRemoveOrderResults contains results of the Storage.RemoveOrder
type StorageMockRemoveOrderResults struct {
	err error
}

// StorageMockRemoveOrderOrigins contains origins of expectations of the Storage.RemoveOrder
type StorageMockRemoveOrderExpectationOrigins struct {
	origin        string
	originOrderId string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRemoveOrder *mStorageMockRemoveOrder) Optional() *mStorageMockRemoveOrder {
	mmRemoveOrder.optional = true
	return mmRemoveOrder
}

// Expect sets up expected params for Storage.RemoveOrder
func (mmRemoveOrder *mStorageMockRemoveOrder) Expect(orderId models.IDType) *mStorageMockRemoveOrder {
	if mmRemoveOrder.mock.funcRemoveOrder != nil {
		mmRemoveOrder.mock.t.Fatalf("StorageMock.RemoveOrder mock is already set by Set")
	}

	if mmRemoveOrder.defaultExpectation == nil {
		mmRemoveOrder.defaultExpectation = &StorageMockRemoveOrderExpectation{}
	}

	if mmRemoveOrder.defaultExpectation.paramPtrs != nil {
		mmRemoveOrder.mock.t.Fatalf("StorageMock.RemoveOrder mock is already set by ExpectParams functions")
	}

	mmRemoveOrder.defaultExpectation.params = &StorageMockRemoveOrderParams{orderId}
	mmRemoveOrder.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRemoveOrder.expectations {
		if minimock.Equal(e.params, mmRemoveOrder.defaultExpectation.params) {
			mmRemoveOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRemoveOrder.defaultExpectation.params)
		}
	}

	return mmRemoveOrder
}

// ExpectOrderIdParam1 sets up expected param orderId for Storage.RemoveOrder
func (mmRemoveOrder *mStorageMockRemoveOrder) ExpectOrderIdParam1(orderId models.IDType) *mStorageMockRemoveOrder {
	if mmRemoveOrder.mock.funcRemoveOrder != nil {
		mmRemoveOrder.mock.t.Fatalf("StorageMock.RemoveOrder mock is already set by Set")
	}

	if mmRemoveOrder.defaultExpectation == nil {
		mmRemoveOrder.defaultExpectation = &StorageMockRemoveOrderExpectation{}
	}

	if mmRemoveOrder.defaultExpectation.params != nil {
		mmRemoveOrder.mock.t.Fatalf("StorageMock.RemoveOrder mock is already set by Expect")
	}

	if mmRemoveOrder.defaultExpectation.paramPtrs == nil {
		mmRemoveOrder.defaultExpectation.paramPtrs = &StorageMockRemoveOrderParamPtrs{}
	}
	mmRemoveOrder.defaultExpectation.paramPtrs.orderId = &orderId
	mmRemoveOrder.defaultExpectation.expectationOrigins.originOrderId = minimock.CallerInfo(1)

	return mmRemoveOrder
}

// Inspect accepts an inspector function that has same arguments as the Storage.RemoveOrder
func (mmRemoveOrder *mStorageMockRemoveOrder) Inspect(f func(orderId models.IDType)) *mStorageMockRemoveOrder {
	if mmRemoveOrder.mock.inspectFuncRemoveOrder != nil {
		mmRemoveOrder.mock.t.Fatalf("Inspect function is already set for StorageMock.RemoveOrder")
	}

	mmRemoveOrder.mock.inspectFuncRemoveOrder = f

	return mmRemoveOrder
}

// Return sets up results that will be returned by Storage.RemoveOrder
func (mmRemoveOrder *mStorageMockRemoveOrder) Return(err error) *StorageMock {
	if mmRemoveOrder.mock.funcRemoveOrder != nil {
		mmRemoveOrder.mock.t.Fatalf("StorageMock.RemoveOrder mock is already set by Set")
	}

	if mmRemoveOrder.defaultExpectation == nil {
		mmRemoveOrder.defaultExpectation = &StorageMockRemoveOrderExpectation{mock: mmRemoveOrder.mock}
	}
	mmRemoveOrder.defaultExpectation.results = &StorageMockRemoveOrderResults{err}
	mmRemoveOrder.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRemoveOrder.mock
}

// Set uses given function f to mock the Storage.RemoveOrder method
func (mmRemoveOrder *mStorageMockRemoveOrder) Set(f func(orderId models.IDType) (err error)) *StorageMock {
	if mmRemoveOrder.defaultExpectation != nil {
		mmRemoveOrder.mock.t.Fatalf("Default expectation is already set for the Storage.RemoveOrder method")
	}

	if len(mmRemoveOrder.expectations) > 0 {
		mmRemoveOrder.mock.t.Fatalf("Some expectations are already set for the Storage.RemoveOrder method")
	}

	mmRemoveOrder.mock.funcRemoveOrder = f
	mmRemoveOrder.mock.funcRemoveOrderOrigin = minimock.CallerInfo(1)
	return mmRemoveOrder.mock
}

// When sets expectation for the Storage.RemoveOrder which will trigger the result defined by the following
// Then helper
func (mmRemoveOrder *mStorageMockRemoveOrder) When(orderId models.IDType) *StorageMockRemoveOrderExpectation {
	if mmRemoveOrder.mock.funcRemoveOrder != nil {
		mmRemoveOrder.mock.t.Fatalf("StorageMock.RemoveOrder mock is already set by Set")
	}

	expectation := &StorageMockRemoveOrderExpectation{
		mock:               mmRemoveOrder.mock,
		params:             &StorageMockRemoveOrderParams{orderId},
		expectationOrigins: StorageMockRemoveOrderExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRemoveOrder.expectations = append(mmRemoveOrder.expectations, expectation)
	return expectation
}

// Then sets up Storage.RemoveOrder return parameters for the expectation previously defined by the When method
func (e *StorageMockRemoveOrderExpectation) Then(err error) *StorageMock {
	e.results = &StorageMockRemoveOrderResults{err}
	return e.mock
}

// Times sets number of times Storage.RemoveOrder should be invoked
func (mmRemoveOrder *mStorageMockRemoveOrder) Times(n uint64) *mStorageMockRemoveOrder {
	if n == 0 {
		mmRemoveOrder.mock.t.Fatalf("Times of StorageMock.RemoveOrder mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRemoveOrder.expectedInvocations, n)
	mmRemoveOrder.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRemoveOrder
}

func (mmRemoveOrder *mStorageMockRemoveOrder) invocationsDone() bool {
	if len(mmRemoveOrder.expectations) == 0 && mmRemoveOrder.defaultExpectation == nil && mmRemoveOrder.mock.funcRemoveOrder == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRemoveOrder.mock.afterRemoveOrderCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRemoveOrder.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RemoveOrder implements mm_storage.Storage
func (mmRemoveOrder *StorageMock) RemoveOrder(orderId models.IDType) (err error) {
	mm_atomic.AddUint64(&mmRemoveOrder.beforeRemoveOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmRemoveOrder.afterRemoveOrderCounter, 1)

	mmRemoveOrder.t.Helper()

	if mmRemoveOrder.inspectFuncRemoveOrder != nil {
		mmRemoveOrder.inspectFuncRemoveOrder(orderId)
	}

	mm_params := StorageMockRemoveOrderParams{orderId}

	// Record call args
	mmRemoveOrder.RemoveOrderMock.mutex.Lock()
	mmRemoveOrder.RemoveOrderMock.callArgs = append(mmRemoveOrder.RemoveOrderMock.callArgs, &mm_params)
	mmRemoveOrder.RemoveOrderMock.mutex.Unlock()

	for _, e := range mmRemoveOrder.RemoveOrderMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRemoveOrder.RemoveOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRemoveOrder.RemoveOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmRemoveOrder.RemoveOrderMock.defaultExpectation.params
		mm_want_ptrs := mmRemoveOrder.RemoveOrderMock.defaultExpectation.paramPtrs

		mm_got := StorageMockRemoveOrderParams{orderId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.orderId != nil && !minimock.Equal(*mm_want_ptrs.orderId, mm_got.orderId) {
				mmRemoveOrder.t.Errorf("StorageMock.RemoveOrder got unexpected parameter orderId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemoveOrder.RemoveOrderMock.defaultExpectation.expectationOrigins.originOrderId, *mm_want_ptrs.orderId, mm_got.orderId, minimock.Diff(*mm_want_ptrs.orderId, mm_got.orderId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRemoveOrder.t.Errorf("StorageMock.RemoveOrder got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRemoveOrder.RemoveOrderMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRemoveOrder.RemoveOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmRemoveOrder.t.Fatal("No results are set for the StorageMock.RemoveOrder")
		}
		return (*mm_results).err
	}
	if mmRemoveOrder.funcRemoveOrder != nil {
		return mmRemoveOrder.funcRemoveOrder(orderId)
	}
	mmRemoveOrder.t.Fatalf("Unexpected call to StorageMock.RemoveOrder. %v", orderId)
	return
}

// RemoveOrderAfterCounter returns a count of finished StorageMock.RemoveOrder invocations
func (mmRemoveOrder *StorageMock) RemoveOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveOrder.afterRemoveOrderCounter)
}

// RemoveOrderBeforeCounter returns a count of StorageMock.RemoveOrder invocations
func (mmRemoveOrder *StorageMock) RemoveOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveOrder.beforeRemoveOrderCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.RemoveOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRemoveOrder *mStorageMockRemoveOrder) Calls() []*StorageMockRemoveOrderParams {
	mmRemoveOrder.mutex.RLock()

	argCopy := make([]*StorageMockRemoveOrderParams, len(mmRemoveOrder.callArgs))
	copy(argCopy, mmRemoveOrder.callArgs)

	mmRemoveOrder.mutex.RUnlock()

	return argCopy
}

// MinimockRemoveOrderDone returns true if the count of the RemoveOrder invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockRemoveOrderDone() bool {
	if m.RemoveOrderMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RemoveOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RemoveOrderMock.invocationsDone()
}

// MinimockRemoveOrderInspect logs each unmet expectation
func (m *StorageMock) MinimockRemoveOrderInspect() {
	for _, e := range m.RemoveOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.RemoveOrder at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRemoveOrderCounter := mm_atomic.LoadUint64(&m.afterRemoveOrderCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RemoveOrderMock.defaultExpectation != nil && afterRemoveOrderCounter < 1 {
		if m.RemoveOrderMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.RemoveOrder at\n%s", m.RemoveOrderMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.RemoveOrder at\n%s with params: %#v", m.RemoveOrderMock.defaultExpectation.expectationOrigins.origin, *m.RemoveOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemoveOrder != nil && afterRemoveOrderCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.RemoveOrder at\n%s", m.funcRemoveOrderOrigin)
	}

	if !m.RemoveOrderMock.invocationsDone() && afterRemoveOrderCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.RemoveOrder at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RemoveOrderMock.expectedInvocations), m.RemoveOrderMock.expectedInvocationsOrigin, afterRemoveOrderCounter)
	}
}

type mStorageMockSetOrder struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockSetOrderExpectation
	expectations       []*StorageMockSetOrderExpectation

	callArgs []*StorageMockSetOrderParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockSetOrderExpectation specifies expectation struct of the Storage.SetOrder
type StorageMockSetOrderExpectation struct {
	mock               *StorageMock
	params             *StorageMockSetOrderParams
	paramPtrs          *StorageMockSetOrderParamPtrs
	expectationOrigins StorageMockSetOrderExpectationOrigins
	results            *StorageMockSetOrderResults
	returnOrigin       string
	Counter            uint64
}

// StorageMockSetOrderParams contains parameters of the Storage.SetOrder
type StorageMockSetOrderParams struct {
	order models.Order
}

// StorageMockSetOrderParamPtrs contains pointers to parameters of the Storage.SetOrder
type StorageMockSetOrderParamPtrs struct {
	order *models.Order
}

// StorageMockSetOrderResults contains results of the Storage.SetOrder
type StorageMockSetOrderResults struct {
	err error
}

// StorageMockSetOrderOrigins contains origins of expectations of the Storage.SetOrder
type StorageMockSetOrderExpectationOrigins struct {
	origin      string
	originOrder string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSetOrder *mStorageMockSetOrder) Optional() *mStorageMockSetOrder {
	mmSetOrder.optional = true
	return mmSetOrder
}

// Expect sets up expected params for Storage.SetOrder
func (mmSetOrder *mStorageMockSetOrder) Expect(order models.Order) *mStorageMockSetOrder {
	if mmSetOrder.mock.funcSetOrder != nil {
		mmSetOrder.mock.t.Fatalf("StorageMock.SetOrder mock is already set by Set")
	}

	if mmSetOrder.defaultExpectation == nil {
		mmSetOrder.defaultExpectation = &StorageMockSetOrderExpectation{}
	}

	if mmSetOrder.defaultExpectation.paramPtrs != nil {
		mmSetOrder.mock.t.Fatalf("StorageMock.SetOrder mock is already set by ExpectParams functions")
	}

	mmSetOrder.defaultExpectation.params = &StorageMockSetOrderParams{order}
	mmSetOrder.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSetOrder.expectations {
		if minimock.Equal(e.params, mmSetOrder.defaultExpectation.params) {
			mmSetOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetOrder.defaultExpectation.params)
		}
	}

	return mmSetOrder
}

// ExpectOrderParam1 sets up expected param order for Storage.SetOrder
func (mmSetOrder *mStorageMockSetOrder) ExpectOrderParam1(order models.Order) *mStorageMockSetOrder {
	if mmSetOrder.mock.funcSetOrder != nil {
		mmSetOrder.mock.t.Fatalf("StorageMock.SetOrder mock is already set by Set")
	}

	if mmSetOrder.defaultExpectation == nil {
		mmSetOrder.defaultExpectation = &StorageMockSetOrderExpectation{}
	}

	if mmSetOrder.defaultExpectation.params != nil {
		mmSetOrder.mock.t.Fatalf("StorageMock.SetOrder mock is already set by Expect")
	}

	if mmSetOrder.defaultExpectation.paramPtrs == nil {
		mmSetOrder.defaultExpectation.paramPtrs = &StorageMockSetOrderParamPtrs{}
	}
	mmSetOrder.defaultExpectation.paramPtrs.order = &order
	mmSetOrder.defaultExpectation.expectationOrigins.originOrder = minimock.CallerInfo(1)

	return mmSetOrder
}

// Inspect accepts an inspector function that has same arguments as the Storage.SetOrder
func (mmSetOrder *mStorageMockSetOrder) Inspect(f func(order models.Order)) *mStorageMockSetOrder {
	if mmSetOrder.mock.inspectFuncSetOrder != nil {
		mmSetOrder.mock.t.Fatalf("Inspect function is already set for StorageMock.SetOrder")
	}

	mmSetOrder.mock.inspectFuncSetOrder = f

	return mmSetOrder
}

// Return sets up results that will be returned by Storage.SetOrder
func (mmSetOrder *mStorageMockSetOrder) Return(err error) *StorageMock {
	if mmSetOrder.mock.funcSetOrder != nil {
		mmSetOrder.mock.t.Fatalf("StorageMock.SetOrder mock is already set by Set")
	}

	if mmSetOrder.defaultExpectation == nil {
		mmSetOrder.defaultExpectation = &StorageMockSetOrderExpectation{mock: mmSetOrder.mock}
	}
	mmSetOrder.defaultExpectation.results = &StorageMockSetOrderResults{err}
	mmSetOrder.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSetOrder.mock
}

// Set uses given function f to mock the Storage.SetOrder method
func (mmSetOrder *mStorageMockSetOrder) Set(f func(order models.Order) (err error)) *StorageMock {
	if mmSetOrder.defaultExpectation != nil {
		mmSetOrder.mock.t.Fatalf("Default expectation is already set for the Storage.SetOrder method")
	}

	if len(mmSetOrder.expectations) > 0 {
		mmSetOrder.mock.t.Fatalf("Some expectations are already set for the Storage.SetOrder method")
	}

	mmSetOrder.mock.funcSetOrder = f
	mmSetOrder.mock.funcSetOrderOrigin = minimock.CallerInfo(1)
	return mmSetOrder.mock
}

// When sets expectation for the Storage.SetOrder which will trigger the result defined by the following
// Then helper
func (mmSetOrder *mStorageMockSetOrder) When(order models.Order) *StorageMockSetOrderExpectation {
	if mmSetOrder.mock.funcSetOrder != nil {
		mmSetOrder.mock.t.Fatalf("StorageMock.SetOrder mock is already set by Set")
	}

	expectation := &StorageMockSetOrderExpectation{
		mock:               mmSetOrder.mock,
		params:             &StorageMockSetOrderParams{order},
		expectationOrigins: StorageMockSetOrderExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSetOrder.expectations = append(mmSetOrder.expectations, expectation)
	return expectation
}

// Then sets up Storage.SetOrder return parameters for the expectation previously defined by the When method
func (e *StorageMockSetOrderExpectation) Then(err error) *StorageMock {
	e.results = &StorageMockSetOrderResults{err}
	return e.mock
}

// Times sets number of times Storage.SetOrder should be invoked
func (mmSetOrder *mStorageMockSetOrder) Times(n uint64) *mStorageMockSetOrder {
	if n == 0 {
		mmSetOrder.mock.t.Fatalf("Times of StorageMock.SetOrder mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSetOrder.expectedInvocations, n)
	mmSetOrder.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSetOrder
}

func (mmSetOrder *mStorageMockSetOrder) invocationsDone() bool {
	if len(mmSetOrder.expectations) == 0 && mmSetOrder.defaultExpectation == nil && mmSetOrder.mock.funcSetOrder == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSetOrder.mock.afterSetOrderCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSetOrder.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SetOrder implements mm_storage.Storage
func (mmSetOrder *StorageMock) SetOrder(order models.Order) (err error) {
	mm_atomic.AddUint64(&mmSetOrder.beforeSetOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmSetOrder.afterSetOrderCounter, 1)

	mmSetOrder.t.Helper()

	if mmSetOrder.inspectFuncSetOrder != nil {
		mmSetOrder.inspectFuncSetOrder(order)
	}

	mm_params := StorageMockSetOrderParams{order}

	// Record call args
	mmSetOrder.SetOrderMock.mutex.Lock()
	mmSetOrder.SetOrderMock.callArgs = append(mmSetOrder.SetOrderMock.callArgs, &mm_params)
	mmSetOrder.SetOrderMock.mutex.Unlock()

	for _, e := range mmSetOrder.SetOrderMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetOrder.SetOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetOrder.SetOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmSetOrder.SetOrderMock.defaultExpectation.params
		mm_want_ptrs := mmSetOrder.SetOrderMock.defaultExpectation.paramPtrs

		mm_got := StorageMockSetOrderParams{order}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.order != nil && !minimock.Equal(*mm_want_ptrs.order, mm_got.order) {
				mmSetOrder.t.Errorf("StorageMock.SetOrder got unexpected parameter order, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetOrder.SetOrderMock.defaultExpectation.expectationOrigins.originOrder, *mm_want_ptrs.order, mm_got.order, minimock.Diff(*mm_want_ptrs.order, mm_got.order))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetOrder.t.Errorf("StorageMock.SetOrder got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSetOrder.SetOrderMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetOrder.SetOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmSetOrder.t.Fatal("No results are set for the StorageMock.SetOrder")
		}
		return (*mm_results).err
	}
	if mmSetOrder.funcSetOrder != nil {
		return mmSetOrder.funcSetOrder(order)
	}
	mmSetOrder.t.Fatalf("Unexpected call to StorageMock.SetOrder. %v", order)
	return
}

// SetOrderAfterCounter returns a count of finished StorageMock.SetOrder invocations
func (mmSetOrder *StorageMock) SetOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetOrder.afterSetOrderCounter)
}

// SetOrderBeforeCounter returns a count of StorageMock.SetOrder invocations
func (mmSetOrder *StorageMock) SetOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetOrder.beforeSetOrderCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.SetOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetOrder *mStorageMockSetOrder) Calls() []*StorageMockSetOrderParams {
	mmSetOrder.mutex.RLock()

	argCopy := make([]*StorageMockSetOrderParams, len(mmSetOrder.callArgs))
	copy(argCopy, mmSetOrder.callArgs)

	mmSetOrder.mutex.RUnlock()

	return argCopy
}

// MinimockSetOrderDone returns true if the count of the SetOrder invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockSetOrderDone() bool {
	if m.SetOrderMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetOrderMock.invocationsDone()
}

// MinimockSetOrderInspect logs each unmet expectation
func (m *StorageMock) MinimockSetOrderInspect() {
	for _, e := range m.SetOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.SetOrder at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSetOrderCounter := mm_atomic.LoadUint64(&m.afterSetOrderCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetOrderMock.defaultExpectation != nil && afterSetOrderCounter < 1 {
		if m.SetOrderMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.SetOrder at\n%s", m.SetOrderMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.SetOrder at\n%s with params: %#v", m.SetOrderMock.defaultExpectation.expectationOrigins.origin, *m.SetOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetOrder != nil && afterSetOrderCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.SetOrder at\n%s", m.funcSetOrderOrigin)
	}

	if !m.SetOrderMock.invocationsDone() && afterSetOrderCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.SetOrder at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SetOrderMock.expectedInvocations), m.SetOrderMock.expectedInvocationsOrigin, afterSetOrderCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *StorageMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockGetOrderInspect()

			m.MinimockGetOrderIDsInspect()

			m.MinimockGetReturnIDsInspect()

			m.MinimockRemoveOrderInspect()

			m.MinimockSetOrderInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *StorageMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *StorageMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetOrderDone() &&
		m.MinimockGetOrderIDsDone() &&
		m.MinimockGetReturnIDsDone() &&
		m.MinimockRemoveOrderDone() &&
		m.MinimockSetOrderDone()
}
